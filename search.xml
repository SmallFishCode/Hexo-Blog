<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端学习路线(三)</title>
      <link href="/Hexo-Blog/2023/05/23/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%89)/"/>
      <url>/Hexo-Blog/2023/05/23/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈喽哇，时隔几个月，终于有时间有精力来更新《前端学习路线系列》第三篇，按照本文路线学习完之后，基本上就可以开始找一份前端实习的工作咯，在 <a href="http://smallfish.space/2023/01/17/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)/">前端学习路线第一篇</a> 中，我们学习了有关前端的概念以及学习前端的一些工具和平台以及前端最基础的三件套，在 <a href="http://smallfish.space/2023/01/27/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%8C)/">前端学习路线第二篇</a> 中，我们学习了关于 JavaScript 的进阶基础和 ES6 以及 git 的使用，那么在第三篇当中，我们就要开始上手前端最热门的两大基础框架了 —- <code>Vue</code> &amp; <code>React</code></p><p>按照本文内容学习完成之后，就可以尝试使用框架的脚手架搭建出一个项目进行开发。</p><h1 id="一-什么是前端框架？"><a href="#一-什么是前端框架？" class="headerlink" title="一. 什么是前端框架？"></a>一. 什么是前端框架？</h1><p>前端框架是一种封装了多种 web 开发功能和组件的工具，它可以让开发者 <code>更快速</code>、<code>高效地</code> 构建出优秀的用户界面和交互体验。前端框架提供了一组预先定义的模板、样式、脚本和多种功能模块，从而使开发者能够集中精力在业务逻辑上，而不是每次都从零开始搭建整个系统。</p><blockquote><p>简单来说就是，比如写一个项目就像造一个房子，那么前端框架的作用就是直接给你了一个 <code>毛坯房</code>。</p></blockquote><h3 id="从多个方面来介绍前端框架"><a href="#从多个方面来介绍前端框架" class="headerlink" title="从多个方面来介绍前端框架:"></a>从多个方面来介绍前端框架:</h3><ol><li><p>结构与层次分明：前端框架通过不同的模块和逻辑层次为网站提供了明确的结构和组织方式，使你的代码变得更加清晰和易于维护。</p></li><li><p>效率提升：为开发者提供了大量的预构建组件，例如导航栏、表格、按钮等，能够让开发者更快速地构建用户界面，减少开发时间和成本。</p></li><li><p>响应式设计：前端框架在设计时会考虑到不同设备和屏幕尺寸，使开发的应用程序能够自适应各种设备，提高用户体验。</p></li><li><p>社区与生态：流行的前端框架往往拥有庞大的社区支持，丰富的学习资源以及成熟的插件生态，可以为开发者提供广泛的帮助和支持。</p></li><li><p>代码复用：通过模块化和组件化的方式，前端框架使得开发者可以更方便地重用和分享代码片段，提高开发效率。</p></li><li><p>跨浏览器兼容性：前端框架会尽量解决浏览器兼容性问题，使开发的应用程序在多数主流浏览器中都能够正常运行。</p></li></ol><h1 id="二-Vue"><a href="#二-Vue" class="headerlink" title="二. Vue"></a>二. Vue</h1><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h3><p>Vue.js 是一款用于构建用户界面的渐进式 JavaScript 框架。它主要用于搭建单页面应用（SPA），同时也可以逐步整合进现有的多页面应用。Vue.js 是由尤雨溪创建和维护的，从 2014 年开始逐渐受到广泛关注和使用。Vue 有两个主要版本：Vue 2 和 Vue 3。</p><p>Vue 官网： <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p><h3 id="2-多维度介绍"><a href="#2-多维度介绍" class="headerlink" title="2. 多维度介绍"></a>2. 多维度介绍</h3><ol><li>Vue 2 和 Vue 3 的区别：</li></ol><p>Vue 3 是 Vue 2 的升级版本，其中引入了许多改进和新特性，主要包括：</p><ul><li>性能优化：Vue 3 的虚拟 DOM 重写，提供更快的渲染速度和更低的内存消耗。</li><li>Composition API：引入了组合式 API，让代码更具组织性和可维护性，尤其在复杂的大型应用中体现得更为明显。</li><li>更好的 TypeScript 支持：Vue 3 的源代码使用 TypeScript 编写，使得 Vue 3 和 TypeScript 之间的集成变得更加自然和强大。</li><li>多平台支持（跨平台）：Vue 3 具有与不同平台（Web、小程序和原生应用等）协同工作的能力。</li></ul><ol start="2"><li>周边生态：<br>Vue.js 拥有完善的周边生态系统，主要包括：</li></ol><ul><li>Vuex：用于管理 Vue 应用程序的状态管理库。</li><li>Vue-router：官方提供的前端路由库，用于管理 Vue 应用程序的页面跳转和导航。</li><li>Vue CLI：官方命令行工具，用于快速创建和管理 Vue 项目。</li><li>Vue DevTools：浏览器插件，提供友好的界面帮助调试 Vue 应用程序。</li></ul><ol start="3"><li>优点：</li></ol><ul><li>易学易用：Vue.js 的学习曲线较平缓，文档完善，便于入门。</li><li>灵活性：Vue.js 提供了灵活的组件化开发模式，双向数据绑定和模板语法，有助于提高开发效率。</li><li>响应式系统：Vue.js 的核心特性之一就是响应式数据绑定，能够自动追踪数据变化并更新 DOM。</li><li>社区支持：Vue.js 拥有活跃的社区和丰富的资源，在遇到问题或学习时都能获得及时的帮助。</li></ul><ol start="4"><li>缺点：</li></ol><ul><li>小型项目可能会有性能问题：由于 Vue.js 的双向数据绑定机制，对于一些小型项目可能会出现性能问题。但在大型项目中，这类影响相对较小。</li><li>相对较新：尽管社区不断壮大，但与其他前端框架相比，Vue.js 的历史相对较短，不少企业可能会有所疑虑。</li></ul><ol start="5"><li>使用方法：</li></ol><p>通过官方工具 Vue CLI 可以快速创建和启动 Vue 项目：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装 Vue CLI：npm install -g @vue/cli</span><br><span class="line">创建新项目：vue create my-project</span><br><span class="line">安装依赖：cd my-project &amp;&amp; npm install</span><br><span class="line">启动本地开发服务器：npm run serve</span><br></pre></td></tr></table></figure><ol start="6"><li>使用场景：<br>Vue.js 适用于以下场景：</li></ol><ul><li>单页面应用（SPA）：Vue.js 具有良好的模块化和组件化特性，非常适合搭建单页面应用。</li><li>多页面应用：Vue.js 可以作为现有多页面应用的逐步整合框架。</li><li>跨平台应用：借助 Vue.js 跨平台能力，可以构建 Web、小程序和原生应用等多种类型的应用程序。</li></ul><h1 id="三-React"><a href="#三-React" class="headerlink" title="三. React"></a>三. React</h1><h3 id="1-简单介绍-1"><a href="#1-简单介绍-1" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h3><p>React 是由 Facebook 开发和维护的一个用于构建用户界面的 JavaScript 库，它采用组件化的方式来构建复杂应用，同样适用于单页面应用（SPA）、多页面应用和跨平台应用。</p><p>官网：<a href="https://react.dev/">https://react.dev/</a></p><h3 id="2-多维度介绍-1"><a href="#2-多维度介绍-1" class="headerlink" title="2. 多维度介绍"></a>2. 多维度介绍</h3><ol><li>周边生态：</li></ol><ul><li>Redux：状态管理库</li><li>React-router：前端路由库</li><li>Create React App：命令行工具</li><li>React DevTools：浏览器调试插件</li></ul><ol start="2"><li>优点：</li></ol><ul><li>组件化开发，代码复用高</li><li>虚拟 DOM 机制，渲染性能优秀</li><li>单向数据流，便于应用管理和维护</li><li>庞大的社区支持、丰富的第三方库</li></ul><ol start="3"><li>缺点：</li></ol><ul><li>学习曲线相对陡峭</li><li>只涉及视图层面，需要与其他库或框架整合</li><li>使用方法：通过 Create React App 可以快速创建和启动 React 项目。</li></ul><ol start="4"><li>使用场景：</li></ol><ul><li>单页面应用（SPA）</li><li>多页面应用</li><li>跨平台应用（借助于 React Native 开发移动应用）</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>总结： Vue 和 React 都具备创建各种类型应用程序的能力，具体选择取决于项目需求和团队熟悉程度。Vue 易学易用，而 React 社区更加庞大和成熟。在实际开发过程中，可以根据自己的喜好和项目需求进行选择。</p><h1 id="四-框架学习的路线建议（本文核心）"><a href="#四-框架学习的路线建议（本文核心）" class="headerlink" title="四. 框架学习的路线建议（本文核心）"></a>四. 框架学习的路线建议（本文核心）</h1><p>在上面我们简单了解了一下关于前端框架的作用和使用以及对比和意义等，那么我们应该如何学好一门前端框架呢？</p><p>以下为作者个人观点：</p><p>选择框架：其实所有的前端框架都是相通的，只要学精了一门框架，上手另一门框架会很快，我的个人建议从 Vue 开始学吧，从 Vue2 开始，个人感觉 vue2 的 options API 上手更简单。</p><p>项目 or 原理？：建议先从项目入手，先把框架用熟了，再去找相关原理的文章去学习会更好，理解起来会更快，项目的话建议在 b 站上找一些基础的 vue2 项目去跟着学习，一定要坚持，直到完成一个 vue2 项目。</p><p>进阶：掌握了 vue2 的使用之后，可以直接上 vue3 ，也是同理， 在 b 站上找到对应的 vue3 项目，这种课程是很多的，一定要跟着敲完。</p><p>原理：当你完成了一个 vue2 和 vue3 的项目之后，你再去看一些关于 vue2 vue3 的内容设计，内部实现，比如你在 vue3 当中 main.js 中，app.mount(‘#app’) 它的一个挂载原理是什么？ 以及 vue 实现响应式设计的原理是什么？等等… 到这一步，你对前端框架的掌握已经足够了</p><p>拓展： 研究主流的两个前端框架的异同点，以及设计原理，和周边生态的设计。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h1><blockquote><p>当你按照本文去学习完前端框架之后，你就可以开始找一份前端实习了，并且你的能力应该是足够的！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端学习经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何发布自己的 npm 包</title>
      <link href="/Hexo-Blog/2023/04/04/engineering/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85/"/>
      <url>/Hexo-Blog/2023/04/04/engineering/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-上传-npm-包"><a href="#1-上传-npm-包" class="headerlink" title="1. 上传 npm 包"></a>1. 上传 npm 包</h1><blockquote><p><a href="https://docs.npmjs.com/creating-and-publishing-scoped-public-packages">https://docs.npmjs.com/creating-and-publishing-scoped-public-packages</a></p></blockquote><p>（记得创建 Readme.md）</p><ol><li><p>npm login 登录 npm 账号 (首次登录可能需要邮件验证)</p></li><li><p>npm init --scope=@my-username 自动生成合格的 package.json</p></li><li><p>npm publish –access public 发包</p></li><li><p>关联 github: <a href="https://blog.csdn.net/qq_33495944/article/details/84553637">https://blog.csdn.net/qq_33495944/article/details/84553637</a></p></li><li><p>删除某一版本的 npm 包 npm unpublish <a href="mailto:&#121;&#x6f;&#117;&#114;&#x6e;&#97;&#x6d;&#x65;&#x40;&#49;&#46;&#48;&#x2e;&#x31;">&#121;&#x6f;&#117;&#114;&#x6e;&#97;&#x6d;&#x65;&#x40;&#49;&#46;&#48;&#x2e;&#x31;</a> –force</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识单测</title>
      <link href="/Hexo-Blog/2023/04/03/unit/%E5%88%9D%E8%AF%86%E5%8D%95%E6%B5%8B/"/>
      <url>/Hexo-Blog/2023/04/03/unit/%E5%88%9D%E8%AF%86%E5%8D%95%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是单元测试？"><a href="#1-什么是单元测试？" class="headerlink" title="1. 什么是单元测试？"></a>1. 什么是单元测试？</h1><blockquote><p>单元测试（unit testing）：是指对软件中的最小可测试单元进行检查和验证</p></blockquote><ul><li>浅谈前端单元测试：<a href="https://juejin.cn/post/6844903624301084680">https://juejin.cn/post/6844903624301084680</a></li><li>如何开始做一个简单的单测：<a href="https://juejin.cn/post/7039108357554176037">https://juejin.cn/post/7039108357554176037</a></li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">需要访问数据库的测试不是单元测试</span><br><span class="line"></span><br><span class="line">需要访问网络的测试不是单元测试</span><br><span class="line"></span><br><span class="line">需要访问文件系统的测试不是单元测试</span><br><span class="line"></span><br><span class="line">--- 修改代码的艺术</span><br></pre></td></tr></table></figure><h3 id="现有的测试框架"><a href="#现有的测试框架" class="headerlink" title="现有的测试框架"></a>现有的测试框架</h3><p><code>Jasmine</code>：Behavior-Drive development(BDD)风格的测试框架，在业内较为流行,功能很全面，自带 asssert、mock 功能</p><p><code>Qunit</code>：该框架诞生之初是为了 jquery 的单元测试，后来独立出来不再依赖于 jquery 本身，但是其身上还是脱离不开 jquery 的影子</p><p><code>Mocha</code>：node 社区大神 tj 的作品，可以在 node 和 browser 端使用，具有很强的灵活性，可以选择自己喜欢的断言库，选择测试结果的 report</p><p><code>Jest</code>：来自于 facebook 出品的通用测试框架，Jest 是一个令人愉快的 JavaScript 测试框架，专注于简洁明快。他适用但不局限于使用以下技术的项目：Babel, TypeScript, Node, React, Angular, Vue</p><h1 id="2-单元测试的意义？"><a href="#2-单元测试的意义？" class="headerlink" title="2. 单元测试的意义？"></a>2. 单元测试的意义？</h1><h3 id="1-意义"><a href="#1-意义" class="headerlink" title="1. 意义"></a>1. 意义</h3><ol><li><p>必要性：JavaScript 缺少类型检查，编译期间无法定位到错误，单元测试可以帮助你测试多种异常情况。</p></li><li><p>正确性：测试可以验证代码的正确性，在上线前做到心里有底。</p></li><li><p>自动化：通过 console 虽然可以打印出内部信息，但是这是一次性的事情，下次测试还需要从头来过，效率不能得到保证。通过编写测试用例，可以做到一次编写，多次运行。</p></li><li><p>保证重构：互联网行业产品迭代速度很快，迭代后必然存在代码重构的过程，那怎么才能保证重构后代码的质量呢？有测试用例做后盾，就可以大胆的进行重构。</p></li></ol><h3 id="2-两个常用的单元测试方法论："><a href="#2-两个常用的单元测试方法论：" class="headerlink" title="2. 两个常用的单元测试方法论："></a>2. 两个常用的单元测试方法论：</h3><ul><li><p>TDD（Test-driven development）：测试驱动开发</p></li><li><p>BDD（Behavior-driven development）：行为驱动开发</p></li></ul><h1 id="3-如何使用-Jest-做一个简单的单测？"><a href="#3-如何使用-Jest-做一个简单的单测？" class="headerlink" title="3. 如何使用 Jest 做一个简单的单测？"></a>3. 如何使用 Jest 做一个简单的单测？</h1><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev jest</span><br></pre></td></tr></table></figure><h3 id="2-写一个功能函数"><a href="#2-写一个功能函数" class="headerlink" title="2. 写一个功能函数"></a>2. 写一个功能函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./sum.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = sum;</span><br></pre></td></tr></table></figure><h3 id="3-创建一个单测文件"><a href="#3-创建一个单测文件" class="headerlink" title="3. 创建一个单测文件"></a>3. 创建一个单测文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./test/sum.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">&quot;./sum&quot;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;测试 sum 函数功能&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&quot;2 + 3 是否等于 5&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(sum(<span class="number">2</span>, <span class="number">3</span>)).toBe(<span class="number">5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">&quot;1 + 1 是否等于 2&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(sum(<span class="number">1</span>, <span class="number">1</span>)).toBe(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">&quot;-1 + -1 是否不等于 -1&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(sum(-<span class="number">1</span>, -<span class="number">1</span>)).not.toBe(-<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-配置-package-json"><a href="#4-配置-package-json" class="headerlink" title="4. 配置 package.json"></a>4. 配置 package.json</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-运行-npm-run-test"><a href="#5-运行-npm-run-test" class="headerlink" title="5. 运行 npm run test"></a>5. 运行 npm run test</h3><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2023-04-04-14-54-20_%E5%88%9D%E8%AF%86%E5%8D%95%E6%B5%8B" alt="2023-04-04-14-54-20_初识单测"></p><h3 id="6-生成测试覆盖率报告"><a href="#6-生成测试覆盖率报告" class="headerlink" title="6. 生成测试覆盖率报告"></a>6. 生成测试覆盖率报告</h3><h5 id="1-什么是单元测试覆盖率？"><a href="#1-什么是单元测试覆盖率？" class="headerlink" title="1. 什么是单元测试覆盖率？"></a>1. 什么是单元测试覆盖率？</h5><p>单元测试覆盖率是一种软件测试的度量指标，指在所有功能代码中，完成了单元测试的代码所占的比例。有很多自动化测试框架工具可以提供这一统计数据，其中最基础的计算方式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单元测试覆盖率 = 被测代码行数 / 参测代码总行数 * <span class="number">100</span>%</span><br></pre></td></tr></table></figure><h5 id="2-如何生成？"><a href="#2-如何生成？" class="headerlink" title="2. 如何生成？"></a>2. 如何生成？</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 package.json 的 script 中 加上</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;test:coverage&quot;</span>: <span class="string">&quot;jest --collect-coverage&quot;</span></span><br></pre></td></tr></table></figure><h5 id="3-运行-npm-run-test-coverage"><a href="#3-运行-npm-run-test-coverage" class="headerlink" title="3. 运行 npm run test:coverage"></a>3. 运行 npm run test:coverage</h5><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2023-04-04-14-54-42_%E5%88%9D%E8%AF%86%E5%8D%95%E6%B5%8B" alt="2023-04-04-14-54-42_初识单测"></p><h1 id="4-常用断言库"><a href="#4-常用断言库" class="headerlink" title="4. 常用断言库"></a>4. 常用断言库</h1><p>参考官网等</p>]]></content>
      
      
      <categories>
          
          <category> Unit Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unit Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线(二)</title>
      <link href="/Hexo-Blog/2023/01/27/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%8C)/"/>
      <url>/Hexo-Blog/2023/01/27/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈喽哇，小伙伴们，在上文《<a href="http://smallfish.space/2023/01/17/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)/">前端学习路线一</a>》中，我们学习了什么是前端以及前端岗位需要做那些事情，还有如何入门前端，学习了前端基础三大件 HTML CSS JS, 那么在本文当中我们将会接着上文往下拓展，延伸 ~</p><blockquote><p>本文我们将会学习 JavaScript 更为全面的基础知识和最新的 JavaScript 语法： ES6。因为在前端基础当中 JavaScript 和 ES6 是重中之重！在最后呢，我们再把 git 这个工具的用法学习一下，学完上文和本文的所有内容之后，才算真正的前端入门~</p></blockquote><h1 id="一-JavaScript-基础"><a href="#一-JavaScript-基础" class="headerlink" title="一. JavaScript 基础"></a>一. JavaScript 基础</h1><blockquote><p>JavaScript 的重点在于许多底层概念，重点！我大概将尽可能多的重点单独拿出来并附带相关讲解文章或者视频，因篇幅有限，在此每个知识点都只放一个连接，大家可以自行寻找其他文章，或者等这两天交流群建好了，会在群里分享一些。</p></blockquote><ol><li><p>作用域：<a href="https://juejin.cn/post/7050484619715543047">https://juejin.cn/post/7050484619715543047</a></p></li><li><p>作用域进阶： <a href="https://juejin.cn/post/7053732933495947301">https://juejin.cn/post/7053732933495947301</a></p></li><li><p>变量提升： <a href="https://juejin.cn/post/7076811474055725087">https://juejin.cn/post/7076811474055725087</a></p></li><li><p>预编译： <a href="https://juejin.cn/post/7083057939447021605">https://juejin.cn/post/7083057939447021605</a></p></li><li><p>闭包： <a href="https://juejin.cn/post/6937469222251560990">https://juejin.cn/post/6937469222251560990</a></p></li><li><p>this：<a href="https://juejin.cn/post/6844903746984476686">https://juejin.cn/post/6844903746984476686</a></p></li><li><p>继承：<a href="https://juejin.cn/post/7112302537985753118">https://juejin.cn/post/7112302537985753118</a></p></li><li><p>事件循环：<a href="https://juejin.cn/post/6992167223523541023">https://juejin.cn/post/6992167223523541023</a></p></li><li><p>数据类型：<a href="https://juejin.cn/post/7008332322101526565">https://juejin.cn/post/7008332322101526565</a></p></li><li><p>懒加载：<a href="https://juejin.cn/post/6844903614138286094">https://juejin.cn/post/6844903614138286094</a></p></li></ol><p>除此之外，强烈建议大家去看《你不知道的 javascript》 这本书，需要电子版的小伙伴们后期可以进群，我会在群里分享。</p><p>除了以上列出来的十点之外，还有很多其他的小点，在此我就不一一列举了，大家可以在相关平台上搜到。</p><p>再 b 站看了半天，真的很少有全面精简干练的 javascript 基础课程，要么是大几百集的视频，要么是讲的不是重点，终于找到一个蛮不错的视频：<a href="https://www.bilibili.com/video/BV1x441167iH?p=1&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8">https://www.bilibili.com/video/BV1x441167iH?p=1&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8</a> 这个里面包含了以上列出来的一些知识点，有助于看文章！看个人习惯和时间条件。</p><h1 id="二-ES6"><a href="#二-ES6" class="headerlink" title="二. ES6"></a>二. ES6</h1><h3 id="1-什么是-ES6？"><a href="#1-什么是-ES6？" class="headerlink" title="1. 什么是 ES6？"></a>1. 什么是 ES6？</h3><blockquote><p>划重点！ES6 也是重中之重！一定要学好！</p></blockquote><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><p>简洁的说，es6 就是 javascript 的最新版本，增加了许多新的功能，拓展了很多原有的技术，例如新增的一些对象方法，数字方法等，用来适应日益复杂的前端需求。</p><h3 id="2-怎么学-es6？"><a href="#2-怎么学-es6？" class="headerlink" title="2. 怎么学 es6？"></a>2. 怎么学 es6？</h3><p>在此我只推荐并且强力推荐阮一峰老师的 ES6，需要电子版的小伙伴们可以自行搜索也可以进交流群自取。</p><h1 id="三-Git"><a href="#三-Git" class="headerlink" title="三. Git"></a>三. Git</h1><blockquote><p>在第一篇文章当中我们大概的介绍了一下什么是 git，那么在这里我们就可以系统性的学习一下 git，因为可以说在整个前端生涯中，这都是离不开的工具！</p></blockquote><h3 id="1-什么是-git？"><a href="#1-什么是-git？" class="headerlink" title="1. 什么是 git？"></a>1. 什么是 git？</h3><p>Git（读音为/gɪt/）是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 Linus Torvalds ，这个人我相信大家都知道吧，开源 Linux 系统的发明人。如今，你看到的大部分服务器其实都是运行在 Linux 系统上，令人感到称叹的是，这位大神级别的程序员不仅创造了 Linux 系统。那 Linux 的代码是如何管理的呢？2002 年之前，世界各地的志愿者把源代码文件通过 diff 的方式发给 Linus，然后由 Linus 本人通过手工方式合并代码！要知道，当时的 Linux 的代码量已经很大了，通过人工管理的方式，一是容易出错，二是效率低。于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。最后，出于某种原因，BitMover 公司收回了 Linux 社区的免费使用权，于是 Linus 花了两周时间自己用 C 语言 写了一个分布式版本控制系统，这就是 Git 的由来了。</p><p>以上介绍出自：<a href="https://juejin.cn/post/6974184935804534815">https://juejin.cn/post/6974184935804534815</a></p><h3 id="2-怎么学-git？"><a href="#2-怎么学-git？" class="headerlink" title="2. 怎么学 git？"></a>2. 怎么学 git？</h3><p>推荐文章：<a href="https://juejin.cn/post/6974184935804534815">https://juejin.cn/post/6974184935804534815</a></p><p>推荐视频：<a href="https://www.bilibili.com/video/BV1k34y1e7Mf/?spm_id_from=333.999.0.0&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8">https://www.bilibili.com/video/BV1k34y1e7Mf/?spm_id_from=333.999.0.0&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8</a></p><p>这个视频我真的强推！我也没看完，大概看了一半，真的讲的很好！很 nice！有时间可以看看！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文主要是针对 JS 和 ES6 这两个重点内容进行拆分讲解，因为真的很重要！然后把 git 较为全面的系统学习教程和视频推荐了一下，小伙伴们按照这些文章和视频还有基本路线学的话，应该是很全面很系统的。</p><p>后续如果需要对某一个知识点或者某一块内容进行详细讲解的话，也可以私信我或者评论区留言，有时间的话我都会专门写一篇文章来讲解，因为这个系列主要是对整个前端学习路线的统筹讲解，所以不会细到知识点，大家理解一下, 推荐的文章和视频都是看过一些觉得还不错的，适合大家学习的~</p><p>最后，感谢小伙伴们的支持！大家有建议和反馈可以给我私信或者留言，这个系列如果反响还好的话，会接着更新下去！</p>]]></content>
      
      
      <categories>
          
          <category> 前端学习经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线(一)</title>
      <link href="/Hexo-Blog/2023/01/17/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)/"/>
      <url>/Hexo-Blog/2023/01/17/mine/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇为该系列第一篇，主要是分享 0 基础前端到能够找到第一份实习工作所需要学习的技术和学习这些技术的一些渠道和方法，我也不是很强的大佬，仅供大家参考~</p></blockquote><p>本系列都是针对前端岗位的建议，本文主要针对 0 基础小白群体讲解，有一定基础的同学可跳过本文。</p><h1 id="一-0-基础如何迈出第一步？"><a href="#一-0-基础如何迈出第一步？" class="headerlink" title="一. 0 基础如何迈出第一步？"></a>一. 0 基础如何迈出第一步？</h1><h3 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h3><p>对于刚入门前端的同学或者跨专业来前端的同学来说，我个人感觉对前端岗位有个清楚的定位是非常重要的，抛出以下三个问题，大家看完以下三个问题，有助于理解前端。</p><ol><li>什么是前端？</li><li>前端岗位在工作中主要负责什么内容？</li><li>前端岗位需要和哪些岗位对接，协调？</li></ol><ul><li>  解答问题 1：<a href="https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/10009024">https://baike.baidu.com/item/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/10009024</a></li><li>解答问题 2：<ul><li>  1、根据公司项目要求，负责 PC 端、移动端的前端设计和研发工作；</li><li>  2、根据产品需求，分析并给出合理的页面前端结构解决方案；</li><li>  3、根据产品及项目的前端页面编码，利用 HTML5 相关技术开发手机端应用；</li><li>  4、和后端程序技术有效配合，完成功能的镶嵌和调试工作；</li><li>  5、根据业务需求，封装高复用、可维护性好的前端组件；</li><li>  6、对前端开发框架有深入了解，并参与持续改进；</li></ul></li><li>解答问题 3：<ul><li>  后端、产品、测试、设计、运营等</li></ul></li></ul><p>以上解答仅为个人观点，不全面勿喷。</p><h3 id="2-学习平台及工具"><a href="#2-学习平台及工具" class="headerlink" title="2. 学习平台及工具"></a>2. 学习平台及工具</h3><p>那么，了解了什么是前端岗位之后，我们该如何学习前端呢？有哪些工具和平台能帮助我们学习前端呢？下面介绍一些常用的前端工具和平台。</p><p><code>前端学习工具</code></p><ol><li><p>编程软件（必装）： 这边我个人强推 VSCode，有很多丰富的插件，使用方便，界面主题简约，兼容性好，下载地址：<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p></li><li><p>Node 环境（必装）：是一个可以运行 javascript 代码的环境，现在搞不懂没关系，以后会明白，下载地址：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p></li><li><p>Git （必装）：是一个用来管理代码仓库的工具，国内常用的是 Gitee，国外常用的是 Github， 如果没有科学上网工具的话，建议先使用 Gitee，官网：<a href="https://gitee.com/%EF%BC%8CGit">https://gitee.com/，Git</a> 下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p></li><li><p>Google 浏览器（选装）：浏览器用来展示和搜索，没有科学上网工具的话这边推荐 Edge 浏览器。</p></li></ol><p>安装了以上的工具之后，就能进行简单程序的开发啦，其他的一些插件之类的，可以上 b 站看一些入门视频，看个人意愿。</p><p><code>前端学习平台</code></p><ol><li><p>Github：上面有很多优秀的开源技术和开源项目，以及一些大佬使用 Github 作为博客记录知识，地址：<a href="https://github.com/">https://github.com/</a></p></li><li><p>b 站：这个大家应该都了解，b 站大学，光看文章看不太明白的话，可以上 b 站找一些前端入门视频观看。</p></li><li><p>掘金：这个是程序员的国内活跃大平台，有很多的好东西！强推！地址：<a href="https://juejin.cn/">https://juejin.cn/</a></p></li><li><p>LeetCode：算法刷题平台，我使用的比较多，大家想巩固数据结构与算法可以在这个平台刷题，按照分类刷，地址：<a href="https://leetcode.cn/">https://leetcode.cn/</a></p></li><li><p>牛客网：是一个程序员分享面试经验的平台，在这里可以找到大量很多公司的面试题和一些大佬的分享，地址：<a href="https://www.nowcoder.com/">https://www.nowcoder.com/</a></p></li></ol><p>其他的像 CSDN，知乎等我就不在此推荐了。</p><h1 id="二-前端知识体系"><a href="#二-前端知识体系" class="headerlink" title="二. 前端知识体系"></a>二. 前端知识体系</h1><h3 id="1-底层语言"><a href="#1-底层语言" class="headerlink" title="1. 底层语言"></a>1. 底层语言</h3><p>首先 JavaScript 是构成前端体系的最底层语言，是一门编程语言，这里我推荐几本书大家可以入，加我微信也行，我有一些电子版的：《你不知道的 javascript》上中下，《javascript 高级程序设计》第四版（或者你买最新版）。</p><p>整个前端体系都是围绕 JavaScript 去构建的，所以在学习这门语言的时候，已经要尽可能的学到更多的知识点，把基础打牢！在后面我会介绍一些优秀学习资料。</p><h3 id="2-前端框架"><a href="#2-前端框架" class="headerlink" title="2. 前端框架"></a>2. 前端框架</h3><p>如果你有一定的基础的话，你一定听说过 Vue 和 React，如果没有的话也不要紧，这是两个前端框架，它们的作用就是让你快速的用更简洁的代码写出更优质的项目，它们的底层都离不开 JavaScript，所以想学习框架，一定要把 JavaScript 学好。</p><p>掌握一门前端框架是前端程序员找工作的门槛，也是必备技能，可以这么说，你只要会一门前端框架，就能找到一份工作。</p><p>我的建议是，按照学习路线，先把底层基础学好，然后选择一门框架，先学习框架的使用，再深入研究框架的原理层。</p><h3 id="3-前端工程化"><a href="#3-前端工程化" class="headerlink" title="3. 前端工程化"></a>3. 前端工程化</h3><blockquote><p>这一节是作为加分技能，在此处了解一下整个体系，方便学习。</p></blockquote><p>前端工程化这个概念放在这里感觉有些过早，但是新手们看不太懂没关系，大概了解一下前端有这么个东西，你通过 HTML，CSS，Js 写好的网站，如果想放到对应的域名给其它互联网用户访问的话，那就得使用不用的工程化打包工具，将你的代码进行打包，压缩等。</p><p>在此只需要了解一下前端工程化是一个辅助技能，是前端程序员的进阶技能，我放在这里讲是因为想让大家先了解整个前端体系大概是由哪些部分组成，后续学到会详细描述。</p><h3 id="4-前端的后端语言"><a href="#4-前端的后端语言" class="headerlink" title="4. 前端的后端语言"></a>4. 前端的后端语言</h3><blockquote><p>这一项也是作为加分技能，不是必须技能。</p></blockquote><p>什么是前端的后端语言呢？ 有基础的同学应该知道，前端是负责根据设计图切出对应的网站页面，一个静态页面，拿淘宝官网来说，每个商品的信息，购买量等，都是前端开发人员通过调用一个叫做接口的东西来获取的数据，进而将数据显示在对应的页面上。</p><p>这里就牵扯到了后端，后端绝大多数是使用 java 编程语言，应该是大学学的最多的编程语言， c c++等，现在还有 go，大家先大概了解就行。</p><p>那么什么是前端的后端语言呢？ — <code>node.js</code></p><p>在 node 环境中，可以使用 js 去写接口，通过调用一些 http 服务，或者通过 node.js 的框架如 express 和 koa ，egg 等去写接口，通过这些技术，连接数据库，前端人员就可以通过 javascript 去写接口，和数据库互通，将数据给到前端页面。</p><p>所以，为什么将 node.js 称为前端的后端语言呢，是因为使用的编程语言是 javascript，是前端开发人员都会的语言，所以前端能干的事情自然也越来越多了！</p><h1 id="三-前端基础三大件"><a href="#三-前端基础三大件" class="headerlink" title="三. 前端基础三大件"></a>三. 前端基础三大件</h1><h3 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1. HTML"></a>1. HTML</h3><ol><li>什么是 HTML ？</li></ol><ul><li>  解答：<a href="https://zh.m.wikipedia.org/zh/HTML">https://zh.m.wikipedia.org/zh/HTML</a></li></ul><ol start="2"><li>去哪学习 HTML ？</li></ol><ul><li><p>  关于 HTML 的学习的话，我个人是比较推荐去 菜鸟教程 这种简约的网站上去学习，大部分人会有个误区，去找一些视频去跟着看，比如 b 站的 pink 老师，尚硅谷等，我大概看了一眼，视频时长都在好多好多好多小时往上，先不说新手能不能坚持看完，看完一遍可能前面就忘了，实在是太过冗余，没有必要。</p></li><li><p>  所以我推荐去看文章，教程，然后学完三件套之后去找个做网站的基础视频去跟着敲，敲出一个静态网站就好，效率高很多！</p></li><li><p>  因为 HTML 本质上其实就是一些代码标签，把常用的那些记住，多用几次掌握特性就好了。</p></li><li><p>  菜鸟教程学习地址： <a href="https://www.runoob.com/html/html-intro.html">https://www.runoob.com/html/html-intro.html</a></p></li><li><p>  其他的话，推荐平台： 掘金， b 站</p></li></ul><ol start="3"><li>学到什么程度？</li></ol><ul><li>  就像我刚才所说，学到你能够随意打开一个中等复杂的网站，能用 HTML 和 CSS 基本全部做出来就行了，前期跟着 b 站视频或者菜鸟教程学，后面自己独立写。</li></ul><h3 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2. CSS"></a>2. CSS</h3><ol><li>什么是 CSS ？</li></ol><ul><li>  维基百科：<a href="https://zh.wikipedia.org/wiki/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%B1%82%E5%8F%A0%E6%A0%B7%E5%BC%8F%E8%A1%A8</a></li></ul><ol start="2"><li>如何学习 CSS？</li></ol><ul><li><p>  在此我同样推荐菜鸟教程：<a href="https://www.runoob.com/css/css-intro.html">https://www.runoob.com/css/css-intro.html</a></p></li><li><p>  如果觉得光看文章不太行的同学们，我建议和 b 站教程结合看，但是不要全都看，看个前面一些，对 CSS 和 HTML 有个大概的了解，知道是个啥，怎么用之后，最好还是只看文章，效率高很多。</p></li></ul><ol start="3"><li>怎么检验学习成果？</li></ol><ul><li><p>  当你觉得 HTML 和 CSS 学的差不多的时候，想检验一下成果，我找了一个 b 站视频，跟着他敲，看看能不能理解所有的过程：<a href="https://www.bilibili.com/video/BV11t4y1t7Vc?p=2&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8">https://www.bilibili.com/video/BV11t4y1t7Vc?p=2&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8</a></p></li><li><p>  当你跟着敲完之后，全都理解了，这个时候你可以去找个官网自己独立写，比如小米官网：<a href="https://www.mi.com/index.html">https://www.mi.com/index.html</a></p></li></ul><h3 id="3-JS"><a href="#3-JS" class="headerlink" title="3. JS"></a>3. JS</h3><ol><li>什么是 JS？</li></ol><ul><li><p>  前面我们讲到了 HTML CSS，那么在这里我给大家再讲讲三者的关系，如果说写一个页面是造房子的话：</p></li><li><p>  HTML 相当于地基，砖头，用来搭建最基本的页面结构。</p></li><li><p>  CSS 相当于瓷砖和装饰品，CSS 在 HTML 的基础结构上，进行装饰，让原本生硬的 HTML 结构变的好看！就像大家所看到的各大官网的页面！</p></li><li><p>  JS 就像房子里的那些功能品： 比如烤箱，烤箱是人来操作的，给人们提供了一些交互功能，使人能够通过它完成一些事情，比如烤面包。而 JS 就是提供给程序员使用的语言，去操作页面上的一些数据和结构，是动态的。</p></li><li><p>  维基百科：<a href="https://zh.m.wikipedia.org/zh/JavaScript">https://zh.m.wikipedia.org/zh/JavaScript</a></p></li></ul><ol start="2"><li>怎么学 JS ？</li></ol><ul><li><p>  学习 JS 的话我比较推荐看视频，因为 JS 基础很重要，能多看一个知识点就多看一点。</p></li><li><p>  视频为主，文章为辅，b 站视频：<a href="https://www.bilibili.com/video/BV1ux411d75J/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8">https://www.bilibili.com/video/BV1ux411d75J/?spm_id_from=333.337.search-card.all.click&amp;vd_source=f46700679cdee12fe72e5203b34fc6b8</a> （黑马视频，感觉还行，后面有好的会推荐）</p></li><li><p>看了一定的入门视频之后，来看推荐文章：</p><ul><li>  <a href="https://juejin.cn/post/6985459853183434789">https://juejin.cn/post/6985459853183434789</a></li><li>  <a href="https://www.runoob.com/js/js-tutorial.html%EF%BC%88%E8%8F%9C%E9%B8%9F%EF%BC%8C%E5%BC%BA%E6%8E%A8%EF%BC%89">https://www.runoob.com/js/js-tutorial.html（菜鸟，强推）</a></li></ul></li></ul><ol start="3"><li>学到什么程度？</li></ol><ul><li><p>  这个 JS 的话，内容比较多，掌握的越多越好！</p></li><li><p>  《javascript 高级程序设计》前六章还有第十章的内容都懂的差不多就行，不一定要看书，去找对应的内容看也行，主要是掌握，这个书拼多多买不贵，也可以找电子版。</p></li><li><p>  《你不知道的 javascript》看完上卷，就是作用域，闭包等知识点都看懂</p></li></ul><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>因为感觉东西还是蛮多的，可能很多地方写的不是很详细，理解一下哈，学习过程中遇到问题可以私信我或者加我联系方式，看到都会回复，后续人数如果够多的话会考虑组一个学习交流群，在里面方便发一些学习文章以及答疑，后台＋。</p><blockquote><p>这是本系列第一篇，主要介绍前端基础的学习，本系列还会有几篇，可以关注一下，后面会陆续更新，我尽力把文章质量保证好，让大家都能有所收货，如果有啥建议的话也可以私信提或者评论区提建议！感谢支持~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端学习经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的历史</title>
      <link href="/Hexo-Blog/2022/12/17/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2/"/>
      <url>/Hexo-Blog/2022/12/17/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>本文会给大家介绍浏览器的单进程架构时代到多进程架构时代，大家看完之后可以深入了解当前浏览器架构，入口：<a href="http://smallfish.space/2022/12/16/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/">浏览器架构</a></p><h1 id="2-浏览器历史"><a href="#2-浏览器历史" class="headerlink" title="2. 浏览器历史"></a>2. 浏览器历史</h1><h3 id="1-单进程浏览器时代"><a href="#1-单进程浏览器时代" class="headerlink" title="1. 单进程浏览器时代"></a>1. 单进程浏览器时代</h3><p>顾名思义，单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-17-22-27-20_%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2" alt="2022-12-17-22-27-20_浏览器的历史"></p><p>如此多的功能模块运行在一个进程里，是导致单进程浏览器不稳定、不流畅和不安全的一个主要因素。下面我就来一一分析下出现这些问题的原因：</p><ol><li><code>不稳定</code></li></ol><p>早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。</p><p>除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃</p><ol start="2"><li><code>不流畅</code></li></ol><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。</p><p>比如，下面这个无限循环的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeze</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;freeze&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">freeze()</span><br></pre></td></tr></table></figure><p>如果让这个脚本运行在一个单进程浏览器的页面里，你感觉会发生什么？</p><p>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。这块内容要继续往深的地方讲就到页面的事件循环系统了，具体相关内容我会在后面的模块中为你深入讲解。</p><p>除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的<code>内存泄漏</code>也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢</p><ol start="3"><li><code>不安全</code></li></ol><p>这里依然可以从插件和页面脚本两个方面来解释该原因。</p><p>插件可以使用 C/C++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。</p><p>至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。</p><blockquote><p>以上这些就是当时浏览器的特点，不稳定，不流畅，而且不安全。这是一段不堪回首的过去，也许你没有经历过，不过你可以想象一下这样的场景：当你正在用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应，然后你发现你给老板写的邮件页面也随之消失了，这时你的心情会不会和页面一样崩溃呢。</p></blockquote><h3 id="2-多进程浏览器时代"><a href="#2-多进程浏览器时代" class="headerlink" title="2. 多进程浏览器时代"></a>2. 多进程浏览器时代</h3><p>好在现代浏览器已经解决了这些问题，是如何解决的呢？这就得聊聊我们这个“多进程浏览器时代”了</p><h5 id="1-早期多进程浏览器时代"><a href="#1-早期多进程浏览器时代" class="headerlink" title="1. 早期多进程浏览器时代"></a>1. 早期多进程浏览器时代</h5><p>你可以先看看下面这张图，这是 2008 年 Chrome 发布时的进程架构。</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-17-22-49-22_%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2" alt="2022-12-17-22-49-22_浏览器的历史"></p><p>从图中可以看出，Chrome 的页面是运行在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过 IPC 机制进行通信（如图中虚线部分）。</p><ol><li><p>我们先看看如何解决不稳定的问题。由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。</p></li><li><p>接下来再来看看不流畅的问题是如何解决的。同样，JavaScript 也是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本是运行在它们自己的渲染进程中的。所以当我们再在 Chrome 中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。</p><p> 对于内存泄漏的解决方法那就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄漏问题。</p></li><li><p>最后我们再来看看上面的两个安全问题是怎么解决的。采用多进程架构的额外好处是可以使用安全沙箱，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p></li></ol><p>好了，分析完早期的 Chrome 浏览器后，相信你已经了解了浏览器采用多进程架构的必要性</p><h5 id="2-目前的多进程架构"><a href="#2-目前的多进程架构" class="headerlink" title="2. 目前的多进程架构"></a>2. 目前的多进程架构</h5><p>我单独写了一篇，入口: <a href="http://smallfish.space/2022/12/16/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/">目前的多进程架构</a></p><h3 id="3-未来面向服务的架构"><a href="#3-未来面向服务的架构" class="headerlink" title="3. 未来面向服务的架构"></a>3. 未来面向服务的架构</h3><p>为了目前多架构存在的问题，在 2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。</p><p>Chrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-17-23-37-41_%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2" alt="2022-12-17-23-37-41_浏览器的历史"></p><p>目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。</p><p>Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为 Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。</p><p>同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-17-23-41-42_%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2" alt="2022-12-17-23-41-42_浏览器的历史"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。</p><p>最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了<code>面向服务架构（SOA）</code>形式，这也是 Chrome 团队现阶段的一个主要任务。</p><p>鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过 Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到 Chrome 新的变化。</p><p>总体说来，Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器架构</title>
      <link href="/Hexo-Blog/2022/12/16/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/"/>
      <url>/Hexo-Blog/2022/12/16/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote><p>本文以 Chrome 的架构为例子来介绍, 即目前的多进程架构时代, 其余见 <a href="http://smallfish.space/2022/12/17/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2/">浏览器历史</a></p></blockquote><p>目前没有关于如何构建网页浏览器的标准规范，因此一个浏览器的实现方法和另外一个可能完全不同。可以是具有多个线程的一个进程，也可以是几个通过 IPC 进行通信的多个进程</p><p>我们以 Chrome 的架构为例子来介绍。顶部是 <code>浏览器主进程</code>，负责协调应用程序的其他进程。对于 <code>渲染进程</code>，将会有多个并且分配给每个 tab。现在，Chrome 为每个 tab 页创建提供单独的进程，包括 iframe</p><h1 id="2-浏览器架构的组成部分"><a href="#2-浏览器架构的组成部分" class="headerlink" title="2. 浏览器架构的组成部分"></a>2. 浏览器架构的组成部分</h1><h3 id="1-架构图"><a href="#1-架构图" class="headerlink" title="1. 架构图"></a>1. 架构图</h3><p>下面两张图为 Chrome 的多进程架构图。在渲染进程下有多个图层，它表示为每个 tab 页运行了多个渲染进程</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-20-23-52_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E7%AF%87(%E4%B8%80)" alt="2022-12-15-20-23-52_浏览器架构篇(一)"></p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-16-21-10-42_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E7%AF%87(%E4%B8%80)" alt="2022-12-16-21-10-42_浏览器架构篇(一)"></p><h3 id="2-组成部分"><a href="#2-组成部分" class="headerlink" title="2. 组成部分"></a>2. 组成部分</h3><blockquote><p>在上图中我们看到，最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p></blockquote><p>chrome 架构有一下几个组成部分：</p><ol><li><p><code>浏览器主进程</code>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p></li><li><p><code>渲染进程</code>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p></li><li><p><code>GPU 进程</code>：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p></li><li><p><code>网络进程</code>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，现在成为了一个单独的进程。</p></li><li><p><code>插件进程</code>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p></li></ol><p>还有更多的进程，比如扩展进程和实用进程。我们点击浏览器右上角的三个点，选择“更多工具” -&gt; “任务管理器”，它列出了当前正在运行的进程和占用的 cpu/内存量。如下：</p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-16-21-11-06_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E7%AF%87(%E4%B8%80)" alt="2022-12-16-21-11-06_浏览器架构篇(一)"></p><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-16-21-11-18_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E7%AF%87(%E4%B8%80)" alt="2022-12-16-21-11-18_浏览器架构篇(一)"></p><h1 id="3-浏览器多进程架构及其优缺点"><a href="#3-浏览器多进程架构及其优缺点" class="headerlink" title="3. 浏览器多进程架构及其优缺点"></a>3. 浏览器多进程架构及其优缺点</h1><p>上文我们讲到现有的 Chrome 架构是多进程的，那么为什么设计为多进程架构呢？这种架构带来了什么优点和缺点呢？我们来看看：</p><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><blockquote><p>多进程模型提升了浏览器的稳定性、流畅性和安全性</p></blockquote><ol><li><p>每个 tab 页拥有自己进程，页面无响应之后不会影响其他的 tab，当你打开某个网址崩溃了之后，并不会影响其他网页的正常运行。</p></li><li><p>当有一个页面在无限加载或者有很多长时间执行的线程，会导致占用大量资源，其他页面会卡顿或崩溃。</p></li><li><p>为了安全性和沙箱隔离。由于操作系统提供了一种限制进程权限的方法，浏览器可以对一些确定的功能进行精确的沙箱处理。例如，chrome 浏览器严格限制了任意用户输入访问任意文件的进程。</p></li></ol><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h3><ol><li><p>更高的资源占用: 因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</p></li><li><p>更复杂的体系架构: 浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了</p></li></ol><h1 id="4-Tips"><a href="#4-Tips" class="headerlink" title="4. Tips"></a>4. Tips</h1><p>对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题, 见文章：<a href="http://smallfish.space/2022/12/17/chrome/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8E%86%E5%8F%B2/">浏览器历史</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给开源项目提 pr ？</title>
      <link href="/Hexo-Blog/2022/12/15/engineering/%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr/"/>
      <url>/Hexo-Blog/2022/12/15/engineering/%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><blockquote><p>在技术开发的过程中，我们时常会使用到很多开源的框架和库，那么我们能不能、为开源仓库贡献，成为贡献者呢？ 当然可以，本文我们来详细的讲解一下如何给一个开源项目提 pr ？</p></blockquote><h1 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h1><ol><li>首先我们在 github 中找到开源项目的仓库地址，并点击右上角的 fork 到本地仓库。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-14-44-17_%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr" alt="2022-12-15-14-44-17_如何给开源项目提pr"></p><ol start="2"><li><p>接着，我们回到本地仓库使用 git clone 克隆该仓库（使用 https 的方式）</p></li><li><p>我们在本地修改代码，然后推到远程</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;fix: xxx&#x27;</span></span><br><span class="line">git push origin xxx</span><br></pre></td></tr></table></figure><ol start="4"><li>此时回到我们 github 的仓库，点击 pr，再点击 create pull request</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-14-49-13_%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr" alt="2022-12-15-14-49-13_如何给开源项目提pr"></p><ol start="5"><li>填入 pr 信息，此时要注意，看看该开源项目有没有自己的提交规范，按照规范填写信息，最后点击创建</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-14-50-54_%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr" alt="2022-12-15-14-50-54_如何给开源项目提pr"></p><ol start="6"><li>此时你的 pr 就出现在了开源项目中，只需要作者同意合并就完成啦！！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-14-53-04_%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr" alt="2022-12-15-14-53-04_如何给开源项目提pr"></p><ol start="7"><li>tips: 在开发的过程中，要注意该开源项目是否有更新的代码，如下图同步最新代码</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-15-15-12-00_%E5%A6%82%E4%BD%95%E7%BB%99%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%8F%90pr" alt="2022-12-15-15-12-00_如何给开源项目提pr"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>希望本文能帮助到各位想参与开源社区建设的小伙伴们 ~</p>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo + Github + VScode 定制图床</title>
      <link href="/Hexo-Blog/2022/12/04/tools/PicGo_Github_VScode/"/>
      <url>/Hexo-Blog/2022/12/04/tools/PicGo_Github_VScode/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么需要定制图床？"><a href="#1-为什么需要定制图床？" class="headerlink" title="1. 为什么需要定制图床？"></a>1. 为什么需要定制图床？</h1><blockquote><p>当我们在写博客的时候，经常会需要上传许多网络图片，试想一下，当图片来源被删除后，在你的博客中，只剩下了一张图片已失效的 <code>error</code></p></blockquote><h3 id="1-什么是图床？"><a href="#1-什么是图床？" class="headerlink" title="1. 什么是图床？"></a>1. 什么是图床？</h3><ul><li>  图床好比你将一段文章 copy 到了本地的备忘录中，可以称为 <code>备份</code></li></ul><h3 id="2-解决了啥问题"><a href="#2-解决了啥问题" class="headerlink" title="2. 解决了啥问题?"></a>2. 解决了啥问题?</h3><ul><li>  我们看到上面的问题，那么这个时候，如果我们有个图床，就相当于对这张图片进行了一次备份，存放在你指定的位置，不会受到源图片地址的干扰，岂不美哉！！</li></ul><h1 id="2-VScode-PicGo"><a href="#2-VScode-PicGo" class="headerlink" title="2. VScode + PicGo"></a>2. VScode + PicGo</h1><ul><li><p>  打开 VScode 插件商店搜索 PicGo，并安装</p></li><li><p>  打开 VScode 工作区设置，我们此处选择 <code>github</code> 托管服务</p></li><li><p>  我们需要配置以下几个选项：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-08-18-03-04_PicGo_Github_VScode" alt="2022-12-08-18-03-04_PicGo_Github_VScode"></p><ul><li>  此处自定义域名可以使用如下的链接，国内访问更快！</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//cdn.jsdelivr.net/gh/SmallFishCode/PicGo</span></span><br><span class="line"></span><br><span class="line">https:<span class="comment">//cdn.jsdelivr.net/gh/用户名/仓库名</span></span><br></pre></td></tr></table></figure><h1 id="3-Github"><a href="#3-Github" class="headerlink" title="3. Github"></a>3. Github</h1><ul><li><p>  我们打开 github 新建一个仓库，将信息填入到第二步当中的配置中</p></li><li><p>  获取 token，打开 settings，看到如下：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-08-18-02-21_PicGo_Github_VScode" alt="2022-12-08-18-02-21_PicGo_Github_VScode"></p><ul><li>  此时，点击右侧新建 token，设置过期时间，选中第一个：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SmallFishCode/PicGo/2022-12-08-18-02-51_PicGo_Github_VScode" alt="2022-12-08-18-02-51_PicGo_Github_VScode"></p><ul><li>  最后将得到的 token 填入到第二步配置中就好啦！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fish-Node 使用文档</title>
      <link href="/Hexo-Blog/2022/11/30/node/Fish-Node%20%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>/Hexo-Blog/2022/11/30/node/Fish-Node%20%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-目录配置"><a href="#1-目录配置" class="headerlink" title="1. 目录配置"></a>1. 目录配置</h1><p>目前支持:</p><ul><li>config: 配置数据库信息</li><li>controller: 业务逻辑存放</li><li>model: 数据库相关配置</li><li>routes: 路由文件存放</li><li>service: 服务层文件</li><li>index.js: 入口文件</li></ul><h1 id="2-Index-js"><a href="#2-Index-js" class="headerlink" title="2. Index.js"></a>2. Index.js</h1><h3 id="1-使用规则-约定-："><a href="#1-使用规则-约定-：" class="headerlink" title="1. 使用规则 (约定)："></a>1. 使用规则 (约定)：</h3><ul><li>npm i</li><li>引入 <code>fish-node</code>，并创建实例</li><li>调用 go 方法启动在 (任意) 3000 端口</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Fish = <span class="built_in">require</span>(<span class="string">&#x27;fish-node&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fish = <span class="keyword">new</span> Fish()</span><br><span class="line"></span><br><span class="line">fish.go(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h1 id="3-Routes"><a href="#3-Routes" class="headerlink" title="3. Routes"></a>3. Routes</h1><h3 id="1-路由文件"><a href="#1-路由文件" class="headerlink" title="1. 路由文件"></a>1. 路由文件</h3><ul><li>入口文件: index.js</li></ul><h3 id="2-使用规则"><a href="#2-使用规则" class="headerlink" title="2. 使用规则:"></a>2. 使用规则:</h3><ul><li><p>仅需在 <code>module.exports = &#123;&#125;</code> 中抛出对应的业务逻辑</p></li><li><p>一个接口对应：method + path + 业务逻辑 (业务逻辑抽离到 controller 文件夹)</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">fish</span>) =&gt;</span> (&#123;</span><br><span class="line"><span class="string">&#x27;get /&#x27;</span>: fish.$ctrl.home.index,</span><br><span class="line"><span class="string">&#x27;get /detail&#x27;</span>: fish.$ctrl.home.detail,</span><br><span class="line"><span class="string">&#x27;get /test&#x27;</span>: fish.$ctrl.home.test,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>多个路由文件，直接创建文件即可，不用导入导出，自动引入，例如，在 routes 下创建 user.js</p></li><li><p>约定语法和上面 index.js 中一样，直接抛出，此处并没有将业务逻辑抽离到 controller 中，看个人习惯。</p></li><li><p>注意到此处的 ctx 并不是直接使用，而是需要使用 fish 调用 ctx</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="string">&#x27;get /&#x27;</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> name = <span class="keyword">await</span> fish.$service.user.getName()</span><br><span class="line">fish.ctx.body = <span class="string">&#x27;用户名：&#x27;</span> + name</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&#x27;get /detail&#x27;</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> age = <span class="keyword">await</span> fish.$service.user.getAge()</span><br><span class="line">fish.ctx.body = <span class="string">&#x27;用户年龄：&#x27;</span> + age</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Contorller"><a href="#4-Contorller" class="headerlink" title="4. Contorller"></a>4. Contorller</h1><blockquote><p>业务逻辑层</p></blockquote><h3 id="1-使用规则："><a href="#1-使用规则：" class="headerlink" title="1. 使用规则："></a>1. 使用规则：</h3><ul><li>与整体规则相似，直接抛出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">index</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line">fish.ctx.body = <span class="string">&#x27;Ctrl Home&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">detail</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line">fish.ctx.body = <span class="string">&#x27;Ctrl Detail&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">test</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line">fish.ctx.body = <span class="string">&#x27;Test fish-node！！&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意到，此处键名是对应的路径，例如我要在用户访问 <code>/detail</code> 时返回 Ctrl Detail ，那我只需要在 routes 中使用 fish 关键字：</p></li><li><p>fish.$ctrl.home.detail home 指的是你在 controller 目录下对应文件的名字，detail 则是抛出对象的键名</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">fish</span>) =&gt;</span> (&#123;</span><br><span class="line"><span class="string">&#x27;get /detail&#x27;</span>: fish.$ctrl.home.detail,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="5-MySQL-接入"><a href="#5-MySQL-接入" class="headerlink" title="5. MySQL 接入"></a>5. MySQL 接入</h1><blockquote><p>目前只支持 MySQL</p></blockquote><h3 id="1-使用规则"><a href="#1-使用规则" class="headerlink" title="1. 使用规则"></a>1. 使用规则</h3><ul><li>只需要在 config 的 index.js 中添加如下配置即可</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">db</span>: &#123;</span><br><span class="line"><span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span>, <span class="comment">// 使用的数据库名</span></span><br><span class="line"><span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 地址</span></span><br><span class="line"><span class="attr">database</span>: <span class="string">&#x27;fish&#x27;</span>, <span class="comment">// 库名</span></span><br><span class="line"><span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>, <span class="comment">// 用户名</span></span><br><span class="line"><span class="attr">password</span>: <span class="string">&#x27;******&#x27;</span>, <span class="comment">// 密码</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例如此时我需要访问 localhost:3000 的时候从数据库中读取数据，只需要在 controller 对应文件下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">index</span>: <span class="keyword">async</span> (fish) =&gt; &#123;</span><br><span class="line">fish.ctx.body = <span class="keyword">await</span> fish.$model.user.findOne(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: <span class="number">2</span> &#125; &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>此处使用的 mysql2 的搜索语法</li></ul><h1 id="6-持续更新中…"><a href="#6-持续更新中…" class="headerlink" title="6. 持续更新中…"></a>6. 持续更新中…</h1>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解 LRU 算法</title>
      <link href="/Hexo-Blog/2022/11/25/vue/%E8%AF%A6%E8%A7%A3%20LRU%20%E7%AE%97%E6%B3%95/"/>
      <url>/Hexo-Blog/2022/11/25/vue/%E8%AF%A6%E8%A7%A3%20LRU%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是-LRU-算法？"><a href="#1-什么是-LRU-算法？" class="headerlink" title="1. 什么是 LRU 算法？"></a>1. 什么是 LRU 算法？</h1><blockquote><p>LRU (Least Recently Used 最近最少使用)</p></blockquote><blockquote><p>LRU用通俗的话来说就是最近被频繁访问的数据会具备更高的留存，淘汰那些不常被访问的数据。</p></blockquote><p>力扣中有一道 LRU 算法题大家可以看看：<a href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a><br>可以先理解题目意思，如果不理解我们接着往下走</p><h1 id="2-我们用几张图来理解一下"><a href="#2-我们用几张图来理解一下" class="headerlink" title="2. 我们用几张图来理解一下"></a>2. 我们用几张图来理解一下</h1><p>假设我是一个卖玩具的商人，我在街上租了一个只能放下三个玩具（没办法太穷了）的摊位，所以大部分的玩具都没摆出来而是放在仓库里。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6332e1e3e03f43948bfa7cc2c621ace2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>好家伙，终于有个人来问了，我赶紧把一个玩具摆在了第一个格子…</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24067c0e5af04ebabae198e32410bc0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>生意太好了，又有人要问自行车，因为第一个格子是黄金位置，所以我把最新的都放那…</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72139a3a166a4820b929ab8a4d5ccba3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>太火爆了，马上我的三个格子就不够用了…</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ef83afb2ce04aad92f595b5bc55c425~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>因为格子从上到下依次最受欢迎，所以我会把下面格子的玩具放回到仓库，给新的玩具腾出点地方来</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a1cdf3450044a3ba6464cac5edcf2ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><p>当然啦，如果客户想看摊位上已经有的玩具，我会把他放到第一个最火热的格子</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab9c9324ab34410291df273f85dfdec5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="3-理解-LRU"><a href="#3-理解-LRU" class="headerlink" title="3. 理解 LRU"></a>3. 理解 LRU</h1><ol><li>有一个最大缓存数量 capacity (是一个正整数) 在上图中代表容量</li><li>有一个 cache 作为容器</li><li>当有人要看某一个玩具时，就是 get 方法，取出对应的玩具，并更新它的位置，以便我们下架最冷清的玩具和取出最火爆的玩具。</li><li>当我们要上架一个玩具时，先判断存不存在货架上，如果不存在，则直接加在最后面，如果存在，就刷新它的位置，放到最前面。</li></ol><h1 id="4-LRU-的应用场景"><a href="#4-LRU-的应用场景" class="headerlink" title="4. LRU 的应用场景"></a>4. LRU 的应用场景</h1><ol><li>Vue 的全局组件 keep-alive 的缓存原理</li><li>redis 等缓存排序<br>…</li></ol><h1 id="5-LRU-算法实现"><a href="#5-LRU-算法实现" class="headerlink" title="5. LRU 算法实现"></a>5. LRU 算法实现</h1><h3 id="1-数组方式实现"><a href="#1-数组方式实现" class="headerlink" title="1. 数组方式实现"></a>1. 数组方式实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LRU 数组实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>] <span class="comment">// &#x27;e&#x27; // 找出哪个最久没被访问, 用 &#x27;e&#x27; 替换掉</span></span><br><span class="line"><span class="comment">// 访问完，放到最前面或最后面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> LRUCache = <span class="function"><span class="keyword">function</span> (<span class="params">capacity</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.capacity = capacity</span><br><span class="line"><span class="built_in">this</span>.cache = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到访问的数据，并刷新它在缓存集合当中的位置</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="built_in">this</span>.cache.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item.key)</span><br><span class="line"><span class="keyword">if</span> (index === -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; value &#125; = <span class="built_in">this</span>.cache[index]</span><br><span class="line"><span class="built_in">this</span>.cache.splice(index, <span class="number">1</span>) <span class="comment">// 移除访问的元素</span></span><br><span class="line"><span class="built_in">this</span>.cache.unshift(&#123;</span><br><span class="line">key,</span><br><span class="line">value,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个访问者</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> index = <span class="built_in">this</span>.cache.findIndex(<span class="function">(<span class="params">item</span>) =&gt;</span> item.key === key) <span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 如果存在，则把它刷新位置</span></span><br><span class="line"><span class="built_in">this</span>.cache.splice(index, <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.cache.length &gt;= <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line"><span class="comment">// 没找到, 并且访问者数量已经达到最大</span></span><br><span class="line"><span class="built_in">this</span>.cache.pop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.cache.unshift(&#123;</span><br><span class="line">key,</span><br><span class="line">value,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其实我们对着注释理解起来，感觉不难，但是我们注意到，在数组的这种实现方式中，我们用到了很多次的 <code>findIndex</code> <code>splice</code> <code>unshift</code> 等方法，那么自然时间复杂度都在 O(n) 之上，所以有没有时间复杂度为 O(1) 的方法呢？</p></li><li><p>我们仔细想想有哪种数据结构查询某个值和取用某个值是 O(1) ? 没错！ 它就是 哈希！！</p></li></ul><h3 id="2-哈希实现"><a href="#2-哈希实现" class="headerlink" title="2. 哈希实现"></a>2. 哈希实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> LRUCache = <span class="function"><span class="keyword">function</span> (<span class="params">capacity</span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.capacity = capacity</span><br><span class="line"><span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到访问的数据，并刷新它在缓存集合当中的位置</span></span><br><span class="line"><span class="comment">// map 的 set 一定会放到最后面</span></span><br><span class="line"><span class="comment">// map 取值内部很复杂</span></span><br><span class="line">LRUCache.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.cache.has(key)) &#123;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="built_in">this</span>.cache.get(key)</span><br><span class="line"><span class="comment">// 更新位置</span></span><br><span class="line"><span class="built_in">this</span>.cache.delete(key)</span><br><span class="line"><span class="built_in">this</span>.cache.set(key, temp)</span><br><span class="line"><span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增一个访问者</span></span><br><span class="line">LRUCache.prototype.put = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.cache.has(key)) &#123;</span><br><span class="line"><span class="comment">// 更新位置</span></span><br><span class="line"><span class="built_in">this</span>.cache.delete(key)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.cache.size &gt;= <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line"><span class="comment">// 移除掉最久没访问的, 如何找到？</span></span><br><span class="line"><span class="comment">// map.keys() 返回一个 key 的迭代器对象，使用 next 方法往下执行，拿到第一个值</span></span><br><span class="line"><span class="comment">// this.cache.keys().next().value</span></span><br><span class="line"><span class="built_in">this</span>.cache.delete(<span class="built_in">this</span>.cache.keys().next().value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.cache.set(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>哈希实现的几个注意点：<ul><li><code>this.cache.has(key)</code> 判断是否存在</li><li><code>this.cache.set(key, temp)</code> 将值存入 hash</li><li><code>this.cache.delete(key)</code> 删除该 hash 表中的 key</li><li><code>this.cache.size</code> 获取到 map 的长度 </li><li><code>this.cache.keys()</code> 获取到一个 迭代器对象里面存放 keys ，通过 next 方法获取第一个 value</li><li>map 的特性：</li></ul>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">a.set(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">a.set(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a.set(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">1</span>, <span class="number">2</span> =&gt; <span class="number">2</span>, <span class="number">3</span> =&gt; <span class="number">3</span>&#125;</span><br><span class="line">a.delete(<span class="number">2</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">a</span><br><span class="line"><span class="function"><span class="title">Map</span>(<span class="params"><span class="number">2</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">1</span>, <span class="number">3</span> =&gt; <span class="number">3</span>&#125;</span><br><span class="line">a.set(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="title">Map</span>(<span class="params"><span class="number">3</span></span>)</span> &#123;<span class="number">1</span> =&gt; <span class="number">1</span>, <span class="number">3</span> =&gt; <span class="number">3</span>, <span class="number">4</span> =&gt; <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="6-收尾"><a href="#6-收尾" class="headerlink" title="6. 收尾"></a>6. 收尾</h1><p>LRU 算法可以结合 Vue 中 keep-alive 源码分析~ 入口：<a href="http://smallfish.space/2022/11/25/vue/keep-alive%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Vue keep-alive 源码解析</a></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keep-alive 源码解析</title>
      <link href="/Hexo-Blog/2022/11/25/vue/keep-alive%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/Hexo-Blog/2022/11/25/vue/keep-alive%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Vue-当中的-keep-alive-和-HTTP-中的-keep-alive"><a href="#1-Vue-当中的-keep-alive-和-HTTP-中的-keep-alive" class="headerlink" title="1. Vue 当中的 keep-alive 和 HTTP 中的 keep-alive"></a>1. Vue 当中的 keep-alive 和 HTTP 中的 keep-alive</h1><p>由于 keep-alive 在 vue 和 http 中都有出现，所以我们在此处将二者一起讨论一下。</p><h3 id="1-HTTP-中的-keep-alive"><a href="#1-HTTP-中的-keep-alive" class="headerlink" title="1. HTTP 中的 keep-alive"></a>1. HTTP 中的 keep-alive</h3><blockquote><p>Keep-Alive 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。(MDN)</p></blockquote><ul><li><p>  语法: <code>Keep-Alive: parameters</code></p></li><li><p>参数: parameters</p><ul><li><p>  一系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 (‘=’) 隔开。下述标识符是可用的：</p></li><li><p>  timeout：指定了一个空闲连接需要保持打开状态的最小时长（以秒为单位）。需要注意的是，如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略。</p></li><li><p>  max：在连接关闭之前，在此连接可以发送的请求的最大值。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。</p></li></ul></li><li><p>  示例</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attr">Connection</span>: Keep-Alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html; charset=utf-<span class="number">8</span></span><br><span class="line"><span class="attr">Date</span>: Thu, <span class="number">11</span> Aug <span class="number">2016</span> <span class="number">15</span>:<span class="number">23</span>:<span class="number">13</span> GMT</span><br><span class="line">Keep-Alive: timeout=<span class="number">5</span>, max=<span class="number">1000</span></span><br><span class="line">Last-Modified: Mon, <span class="number">25</span> Jul <span class="number">2016</span> <span class="number">04</span>:<span class="number">32</span>:<span class="number">39</span> GMT</span><br><span class="line"><span class="attr">Server</span>: Apache</span><br><span class="line"></span><br><span class="line">(body)</span><br></pre></td></tr></table></figure><h3 id="2-Vue-中的-keep-alive"><a href="#2-Vue-中的-keep-alive" class="headerlink" title="2. Vue 中的 keep-alive"></a>2. Vue 中的 keep-alive</h3><blockquote><p><KeepAlive> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。（Vue 官网）</p></blockquote><ol><li><p>是什么？</p><ul><li>keep-alive 是一个 Vue 全局组件</li><li>keep-alive 本身不会渲染出来，也不会出现在父组件链中</li><li>keep-alive 包裹动态组件时，会缓存不活动的组件，而不是销毁它们</li></ul></li><li><p>怎么用？<br>keep-alive 接收三个参数： - include：可传字符串、正则表达式、数组，名称匹配成功的组件会被缓存 - exclude：可传字符串、正则表达式、数组，名称匹配成功的组件不会被缓存 - max：可传数字，限制缓存组件的最大数量, 超过 max 则按照 <code>LRU算法</code> 进行置换</p></li></ol><p>include 和 exclude，传数组情况居多.</p><ul><li>  基础用法:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 非活跃的组件将会被缓存！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">KeepAlive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;activeComponent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">KeepAlive</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>  动态组件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">&quot;allowList&quot;</span> :exclude=<span class="string">&quot;noAllowList&quot;</span> :max=<span class="string">&quot;amount&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;currentComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><ul><li>  路由组件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=<span class="string">&quot;allowList&quot;</span> :exclude=<span class="string">&quot;noAllowList&quot;</span> :max=<span class="string">&quot;amount&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>其他用法是本文重点, 会在下一小点中提到。</p><hr><h1 id="2-Vue-中-keep-alive-的进阶用法"><a href="#2-Vue-中-keep-alive-的进阶用法" class="headerlink" title="2. Vue 中 keep-alive 的进阶用法"></a>2. Vue 中 keep-alive 的进阶用法</h1><h3 id="1-props"><a href="#1-props" class="headerlink" title="1. props"></a>1. props</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> KeepAliveProps &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果指定，则只有与 `include` 名称</span></span><br><span class="line"><span class="comment">   * 匹配的组件才会被缓存。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  include?: MatchPattern</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 任何名称与 `exclude`</span></span><br><span class="line"><span class="comment">   * 匹配的组件都不会被缓存。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  exclude?: MatchPattern</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最多可以缓存多少组件实例。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  max?: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MatchPattern = <span class="built_in">string</span> | <span class="built_in">RegExp</span> | (<span class="built_in">string</span> | <span class="built_in">RegExp</span>)[]</span><br></pre></td></tr></table></figure><h3 id="2-详细使用"><a href="#2-详细使用" class="headerlink" title="2. 详细使用"></a>2. 详细使用</h3><blockquote><p><KeepAlive> 包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们。</p></blockquote><p>任何时候都只能有一个活跃组件实例作为 <KeepAlive> 的直接子节点。</p><p>当一个组件在 <KeepAlive> 中被切换时，它的 activated 和 deactivated 生命周期钩子将被调用，<br>用来替代 mounted 和 unmounted。这适用于 <KeepAlive> 的直接子节点及其所有子孙节点。</p><h3 id="3-include-exclude"><a href="#3-include-exclude" class="headerlink" title="3. include / exclude"></a>3. include / exclude</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用逗号分隔的字符串 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">KeepAlive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">KeepAlive</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 正则表达式 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">KeepAlive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">KeepAlive</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 数组 (使用 <span class="string">`v-bind`</span>) --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">KeepAlive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">KeepAlive</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="4-max"><a href="#4-max" class="headerlink" title="4. max"></a>4. max</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;KeepAlive :max=<span class="string">&quot;10&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/KeepAlive&gt;</span><br></pre></td></tr></table></figure><h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5. 生命周期"></a>5. 生命周期</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;(onActivated, onDeactivated)&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> onActivated(<span class="function">() =&gt;</span>&#123;<span class="string">&#x27; &#x27;</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 调用时机为首次挂载</span></span><br><span class="line"><span class="comment">// 以及每次从缓存中被重新插入时</span></span><br><span class="line">&#125;</span><br><span class="line">) onDeactivated(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 在从 DOM 上移除、进入缓存</span></span><br><span class="line"><span class="comment">// 以及组件卸载时调用</span></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. 使用场景</h3><p>可能大家在平时的开发中会经常遇到这样的场景：有一个可以进行筛选的列表页 List.vue，点击某一项时进入相应的详情页面，等到你从详情页返回 List.vue 时，发现列表页居然刷新了！刚刚的筛选条件都没了！！！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2bdfbc3aec43c388f414a9c74001ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><hr><h1 id="3-keep-alive-源码解析（V2）"><a href="#3-keep-alive-源码解析（V2）" class="headerlink" title="3. keep-alive 源码解析（V2）"></a>3. keep-alive 源码解析（V2）</h1><h3 id="1-keep-alive-在各个生命周期里都做了啥："><a href="#1-keep-alive-在各个生命周期里都做了啥：" class="headerlink" title="1. keep-alive 在各个生命周期里都做了啥："></a>1. keep-alive 在各个生命周期里都做了啥：</h3><ol><li><p>created：初始化一个 cache、keys，前者用来存缓存组件的虚拟 dom 集合，后者用来存缓存组件的 key 集合</p></li><li><p>mounted：实时监听 include、exclude 这两个的变化，并执行相应操作</p></li><li><p>destroyed：删除掉所有缓存相关的东西</p></li></ol><h3 id="2-首先我们在-Vue2-源码中找到这个文件"><a href="#2-首先我们在-Vue2-源码中找到这个文件" class="headerlink" title="2. 首先我们在 Vue2 源码中找到这个文件"></a>2. 首先我们在 Vue2 源码中找到这个文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/components/keep-alive.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line"><span class="attr">abstract</span>: <span class="literal">true</span>, <span class="comment">// 判断此组件是否需要在渲染成真实DOM</span></span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line"><span class="attr">include</span>: patternTypes,</span><br><span class="line"><span class="attr">exclude</span>: patternTypes,</span><br><span class="line"><span class="attr">max</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 创建对象来存储  缓存虚拟dom</span></span><br><span class="line"><span class="built_in">this</span>.keys = [] <span class="comment">// 创建数组来存储  缓存key</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 实时监听include、exclude的变动</span></span><br><span class="line"><span class="built_in">this</span>.$watch(<span class="string">&#x27;include&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">pruneCache(<span class="built_in">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> matches(val, name))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.$watch(<span class="string">&#x27;exclude&#x27;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">pruneCache(<span class="built_in">this</span>, <span class="function">(<span class="params">name</span>) =&gt;</span> !matches(val, name))</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="built_in">this</span>.cache) &#123;</span><br><span class="line"><span class="comment">// 删除所有的缓存</span></span><br><span class="line">pruneCacheEntry(<span class="built_in">this</span>.cache, key, <span class="built_in">this</span>.keys)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 下面讲</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>keep-alive 不会被渲染到页面上，所以 abstract 这个属性至关重要！Vue2</p></blockquote><p>我们可以看到在 destroyed 生命周期中，调用了 <code>pruneCacheEntry</code> 方法，那么我们找到这个函数定义来看看</p><h3 id="3-pruneCacheEntry-函数"><a href="#3-pruneCacheEntry-函数" class="headerlink" title="3. pruneCacheEntry 函数"></a>3. pruneCacheEntry 函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/components/keep-alive.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span>(<span class="params">cache: VNodeCache, key: string, keys: <span class="built_in">Array</span>&lt;string&gt;, current?: VNode</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> cached = cache[key]</span><br><span class="line"><span class="keyword">if</span> (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123;</span><br><span class="line">cached.componentInstance.$destroy() <span class="comment">// 执行组件的destory钩子函数</span></span><br><span class="line">&#125;</span><br><span class="line">cache[key] = <span class="literal">null</span> <span class="comment">// 设为null</span></span><br><span class="line">remove(keys, key) <span class="comment">// 删除对应的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下就是做了三件事：</p><ol><li>遍历集合，执行所有缓存组件的$destroy 方法</li><li>将 cache 对应 key 的内容设置为 null</li><li>删除 keys 中对应的元素</li></ol><h3 id="4-render-函数"><a href="#4-render-函数" class="headerlink" title="4. render 函数"></a>4. render 函数</h3><p>看完缓存组件的卸载，我们在看看 render 函数的作用</p><blockquote><p>以下称 include 为白名单，exclude 为黑名单 render 函数里主要做了这些事：</p></blockquote><ol><li><p>第一步：获取到 keep-alive 包裹的第一个组件以及它的组件名称</p></li><li><p>第二步：判断此组件名称是否能被白名单、黑名单匹配，如果不能被白名单匹配 || 能被黑名单匹配，则直接返回 VNode ，不往下执行，如果不符合，则往下执行第三步</p></li><li><p>第三步：根据组件 ID、tag 生成缓存 key，并在缓存集合中查找是否已缓存过此组件。如果已缓存过，直接取出缓存组件，并更新缓存 key 在 keys 中的位置（这是 LRU 算法的关键），如果没缓存过，则继续第四步</p></li><li><p>第四步：分别在 cache、keys 中保存此组件以及他的缓存 key，并检查数量是否超过 max，超过则根据 LRU 算法进行删除</p></li><li><p>第五步：将此组件实例的 keepAlive 属性设置为 true，这很重要哦，下面会讲到的！</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/components/keep-alive.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default</span><br><span class="line">  <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(slot) <span class="comment">// 找到第一个子组件对象</span></span><br><span class="line">  <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">  <span class="keyword">if</span> (componentOptions) &#123; <span class="comment">// 存在组件参数</span></span><br><span class="line">    <span class="comment">// check pattern</span></span><br><span class="line">    <span class="keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="comment">// 组件名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; include, exclude &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// 条件匹配</span></span><br><span class="line">      <span class="comment">// not included</span></span><br><span class="line">      (include &amp;&amp; (!name || !matches(include, name))) ||</span><br><span class="line">      <span class="comment">// excluded</span></span><br><span class="line">      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> vnode</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; cache, keys &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span> <span class="comment">// 定义组件的缓存key</span></span><br><span class="line">      <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">      <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">      ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      : vnode.key</span><br><span class="line">    <span class="keyword">if</span> (cache[key]) &#123; <span class="comment">// 已经缓存过该组件</span></span><br><span class="line">      vnode.componentInstance = cache[key].componentInstance</span><br><span class="line">      <span class="comment">// make current key freshest</span></span><br><span class="line">      remove(keys, key)</span><br><span class="line">      keys.push(key) <span class="comment">// 调整key排序</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cache[key] = vnode <span class="comment">// 缓存组件对象</span></span><br><span class="line">      keys.push(key)</span><br><span class="line">      <span class="comment">// prune oldest entry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.max &amp;&amp; keys.length &gt; <span class="built_in">parseInt</span>(<span class="built_in">this</span>.max)) &#123; <span class="comment">// 超过缓存数限制，将第一个删除</span></span><br><span class="line">        pruneCacheEntry(cache, keys[<span class="number">0</span>], keys, <span class="built_in">this</span>._vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.data.keepAlive = <span class="literal">true</span> <span class="comment">// 渲染和执行被包裹组件的钩子函数需要用到</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-如何渲染"><a href="#5-如何渲染" class="headerlink" title="5. 如何渲染"></a>5. 如何渲染</h3><p>咱们先来看看 Vue 一个组件是怎么渲染的，咱们从 render 开始说：</p><ul><li><p>  render：此函数会将组件转成 VNode</p></li><li><p>  patch：此函数在初次渲染时会直接渲染根据拿到的 VNode 直接渲染成真实 DOM，第二次渲染开始就会拿 VNode 会跟旧 VNode 对比，打补丁（diff 算法对比发生在此阶段），然后渲染成真实 DOM</p></li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012505072dbb40e39c5edee63e11fc21~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"></p><h3 id="6-keep-alive-本身如何做到不渲染"><a href="#6-keep-alive-本身如何做到不渲染" class="headerlink" title="6. keep-alive 本身如何做到不渲染"></a>6. keep-alive 本身如何做到不渲染</h3><p>刚刚说了，keep-alive 自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的 <code>abstract</code> 的属性值，如果是 true 的话，就跳过该实例，该实例也不会出现在父级链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> options = vm.$options</span><br><span class="line"><span class="comment">// 找到第一个非abstract的父组件实例</span></span><br><span class="line"><span class="keyword">let</span> parent = options.parent</span><br><span class="line"><span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line"><span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">parent = parent.$parent</span><br><span class="line">&#125;</span><br><span class="line">parent.$children.push(vm)</span><br><span class="line">&#125;</span><br><span class="line">vm.$parent = parent</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-包裹组件渲染"><a href="#7-包裹组件渲染" class="headerlink" title="7. 包裹组件渲染"></a>7. 包裹组件渲染</h3><p>咱们再来说说被 keep-alive 包裹着的组件是如何使用缓存的吧。刚刚说了 VNode -&gt; 真实 DOM 是发生在 patch 的阶段，而其实这也是要细分的：VNode -&gt; 实例化 -&gt; _update -&gt; 真实 DOM，而组件使用缓存的判断就发生在实例化这个阶段，而这个阶段调用的是 <code>createComponent</code> 函数，那我们就来说说这个函数吧：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span>(<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> i = vnode.data</span><br><span class="line"><span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line"><span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line"><span class="keyword">if</span> (isDef((i = i.hook)) &amp;&amp; isDef((i = i.init))) &#123;</span><br><span class="line">i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">insert(parentElm, vnode.elm, refElm) <span class="comment">// 将缓存的DOM（vnode.elm）插入父元素中</span></span><br><span class="line"><span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>  在第一次加载被包裹组件时，因为 keep-alive 的 render 先于包裹组件加载之前执行，所以此时 vnode.componentInstance 的值是 undefined，而 keepAlive 是 true，则代码走到 i(vnode, false /_ hydrating _/)就不往下走了</p></li><li><p>  再次访问包裹组件时，vnode.componentInstance 的值就是已经缓存的组件实例，那么会执行 insert(parentElm, vnode.elm, refElm)逻辑，这样就直接把上一次的 DOM 插入到了父元素中。</p></li></ul><h1 id="4-收尾"><a href="#4-收尾" class="headerlink" title="4. 收尾"></a>4. 收尾</h1><p>在看 keep-alive 源码的过程中发现 Vue2 和 Vue3 当中部分地方还是有区别的，后续可能会出一期 Vue3 keep-alive 的文章。</p><p>另外，在本文提到的 LRU 算法，会单独更新一篇文章~</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Koa 与 Express 的异同</title>
      <link href="/Hexo-Blog/2022/11/24/node/%E6%B5%85%E8%B0%88%20Koa%20%E5%92%8C%20Express%20%E7%9A%84%E5%BC%82%E5%90%8C/"/>
      <url>/Hexo-Blog/2022/11/24/node/%E6%B5%85%E8%B0%88%20Koa%20%E5%92%8C%20Express%20%E7%9A%84%E5%BC%82%E5%90%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两者的联系"><a href="#1-两者的联系" class="headerlink" title="1. 两者的联系"></a>1. 两者的联系</h1><ol><li><p>Express 和 Koa 都是出自 <a href="https://link.juejin.cn/?target=https://github.com/tj">TJ Holowaychuk</a> 大神之手。</p></li><li><p>Express 是一个基于 Node.js 平台的 web 应用开发框架。而 Koa 则是 Express 的 <code>升级版</code> Koa 诞生之初正值 Nodejs 推出 <code>async/await</code> 语法之时， Koa 采用这种新的语法特性，丢弃回调函数，实现了了一个轻量优雅的 web 后端框架。</p></li><li><p>两者都采用中间件方式进行开发，并且相关 api 基本是大同小异的。</p></li></ol><hr><h1 id="2-二者的区别"><a href="#2-二者的区别" class="headerlink" title="2. 二者的区别"></a>2. 二者的区别</h1><h3 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1. 架构设计"></a>1. 架构设计</h3><p>Express是一个集合式的框架，自身集成了router，static，views，bodyparse等等常用中间件。这样的设计让开发者能非常快速的搭建一个node后端服务，这个服务功能齐全。可以实现接口服务，静态资源服务，页面服务，甚至文件上传也能实现。但是使用Express就必须引入全部的中间件和功能，不管你有没有用到。</p><p>Koa2的设计思想就是小而美，轻量，插件化设计。只提供最基础的框架，所有功能都通过中间件引入。Koa将Express集成的中间件进行拆分，开发者按需引入即可使用。比如：</p><p>得益于这种设计，用户在选择中间件时有了更多的选项。你可以选择koa提供的中间件(如果koa提供的话)，也可以选择社区或第三方开发的中间件，甚至自己写一个都可以。这在Express上是无法想象的。</p><p>Koa 是 Express 原班人马基于 <code>ES6</code> 新特性重新开发的框架，主要基于 co 中间件，框架自身不包含任何中间件，很多功能需要借助第三方中间件解决，但是由于其基于 ES6 generator 特性的异步流程控制，解决了 “callback hell” 和麻烦的错误处理问题。</p><p>总结来说，Express是一个功能齐全，开箱即用的集合式框架，比较重。Koa2是一个插件化的轻量框架，功能按需引入。</p><h3 id="2-中间件模型"><a href="#2-中间件模型" class="headerlink" title="2. 中间件模型"></a>2. 中间件模型</h3><h5 id="N1-中间件模型结构差异"><a href="#N1-中间件模型结构差异" class="headerlink" title="N1: 中间件模型结构差异"></a>N1: 中间件模型结构差异</h5><p>Express 的中间件模型为 <code>线型</code>，而 Koa 的中间件模型为 U 型，也可称为 <code>洋葱模型</code> 构造中间件</p><ul><li>Express 线型模型示例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.write(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p>Express 中间件有趣的地方：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Express();</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;resolve(<span class="number">1</span>)&#125;, <span class="number">2000</span>))</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f1 start -&gt;&#x27;</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f1 end &lt;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f2 start -&gt;&#x27;</span>);</span><br><span class="line">  next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f2 end &lt;-&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//await sleep();</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f3 service...&#x27;</span>);</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(f1);</span><br><span class="line">app.use(f2);</span><br><span class="line">app.use(f3);</span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, f3)</span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>))</span><br></pre></td></tr></table></figure><p>控制台执行 curl localhost:3000 输出如下，有点迷惑了，不是线性吗？为什么和我们上面讲 Koa 的输出顺序是一致呢？不也是洋葱模型吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1 start -&gt;</span><br><span class="line">f2 start -&gt;</span><br><span class="line">f3 service...</span><br><span class="line">f2 end &lt;-</span><br><span class="line">f1 end &lt;-</span><br></pre></td></tr></table></figure><p>少年，先莫及，再看一段代码。<br>上面我们的 f3 函数其中注释了一条代码 await sleep() 延迟执行，现在让我们打开这个注释。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(); <span class="comment">// 改变之处</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;f3 service...&#x27;</span>);</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台再次执行 curl localhost:3000，发现顺序发生了改变，上游中间件并没有等待 f3 函数执行完毕，就直接执行了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1 start -&gt;</span><br><span class="line">f2 start -&gt;</span><br><span class="line">f2 end &lt;-</span><br><span class="line">f1 end &lt;-</span><br><span class="line">f3 service...</span><br></pre></td></tr></table></figure><blockquote><p>Express 中间件实现是基于 Callback 回调函数同步的，它不会去等待异步（Promise）完成，这也解释了为什么上面的 Demo 我加上异步操作，顺序就被改变了。<br>在 Koa 的中间件机制中使用 Async/Await（背后全是 Promise）以同步的方式来管理异步代码，它则可以等待异步操作。</p></blockquote><ul><li>Koa 洋葱模型示例：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Koa <span class="keyword">from</span> <span class="string">&quot;koa&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  ctx.body += <span class="string">&quot;world&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p>可以看到，Express 实现同样的功能，要比 Koa 多一步。</p><h5 id="N2-洋葱模型实际应用场景"><a href="#N2-洋葱模型实际应用场景" class="headerlink" title="N2: 洋葱模型实际应用场景"></a>N2: 洋葱模型实际应用场景</h5><ul><li>使用 node 服务监控一个请求的响应时间<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中间件源码部分</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;koaRouterPathAggregate, ...baseOptions &#125; = options;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> metrics = <span class="keyword">new</span> BaseServiceMetrics(baseOptions);</span><br><span class="line">    <span class="keyword">const</span> &#123; entry, exit &#125; = metrics;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> linkObj = entry(ctx);</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> otherObj = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (koaRouterPathAggregate) &#123;</span><br><span class="line">                <span class="keyword">const</span> realPath = getKoaRouterPath(ctx, koaRouterPathAggregate);</span><br><span class="line">                <span class="keyword">if</span> (realPath) &#123;</span><br><span class="line">                  otherObj.path = realPath;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exit(ctx, linkObj, otherObj);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务使用部分</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">const</span> entryObj = entry(req); <span class="comment">// 开始监控统计入口，一般在请求开始时执行</span></span><br><span class="line"> <span class="comment">/* todo 计算业务逻辑</span></span><br><span class="line"><span class="comment"> res.writeHead(200, &#123;&#x27;Content-type&#x27; : &#x27;text/html&#x27;&#125;);</span></span><br><span class="line"><span class="comment"> res.write(&#x27;&lt;h1&gt;Node.js&lt;/h1&gt;&#x27;);</span></span><br><span class="line"><span class="comment"> res.end(&#x27;&lt;p&gt;Hello World&lt;/p&gt;&#x27;);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> exit(res, entryObj); <span class="comment">// 开始监控统计出口，一般在计算完执行准备返回时执行</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul><p>业务逻辑开始前调用 entry，逻辑结束后 调用 exit，内部通过 node 自带的 <code>process.hrtime()</code> 获取到当前时间。</p><ul><li>需要回调下一个中间件的处理结果 (待补充)</li></ul><p>如果 Express 也想实现 Koa 的洋葱模型就比较困难，需要开发者在每一个中间件上都添加回调函数。因此 Express 项目真的很难直接使用 Koa 的中间件机制，怪不得 TJ Holowaychuk 大神也要另起炉灶。</p><h3 id="3-异步方式"><a href="#3-异步方式" class="headerlink" title="3. 异步方式"></a>3. 异步方式</h3><ul><li><p>Express 通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express写法</span></span><br><span class="line">app.get(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;/file1&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.status(<span class="number">500</span>).send(<span class="string">&quot;read file1 error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fs.readFile(<span class="string">&quot;/file2&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        res.status(<span class="number">500</span>).send(<span class="string">&quot;read file2 error&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      res.type(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">      res.send(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Koa 通过 generator 和 async/await 使用同步的写法来处理异步，明显好于 callback 和 promise。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> doReadFile();</span><br><span class="line">  ctx.response.type = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">  ctx.response.body = data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-捕获错误"><a href="#4-捕获错误" class="headerlink" title="4. 捕获错误"></a>4. 捕获错误</h3><ul><li><p>Express 沿用 Node.js 的 Error-First 的模式（第一个参数是 error 对象）来捕获错误。由于Express的中间件时线性流程，所以要处理错误信息就必须把error中间件放到最后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err.stack);</span><br><span class="line">  res.status(<span class="number">500</span>).send(<span class="string">&quot;Something broke!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Koa 使用 try/catch 的方式来捕获错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.errorCode) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;捕获到异常&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> (ctx.body = errror.msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-响应机制"><a href="#5-响应机制" class="headerlink" title="5. 响应机制"></a>5. 响应机制</h3><ul><li>Express 立刻响应（res.json/res.send），上层不能再定义其他处理。</li><li>Koa 中间件执行完之后才响应（ctx.body = xxx），每一层都可以对响应进行自己的处理</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写一个 Vite</title>
      <link href="/Hexo-Blog/2022/11/24/engineering/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAVite/"/>
      <url>/Hexo-Blog/2022/11/24/engineering/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAVite/</url>
      
        <content type="html"><![CDATA[<h1 id="MyVite"><a href="#MyVite" class="headerlink" title="MyVite"></a>MyVite</h1><p>建议参考 github 上代码进行解读</p><p><a href="https://github.com/SmallFishCode/MyVite">https://github.com/SmallFishCode/MyVite</a></p><h2 id="1-Vite-的特点"><a href="#1-Vite-的特点" class="headerlink" title="1. Vite 的特点"></a>1. Vite 的特点</h2><ol><li>闪电般的冷启动速度</li><li>即使热模块更换（HMR）</li><li>真正的按需编译</li></ol><h2 id="2-Vite-的要求"><a href="#2-Vite-的要求" class="headerlink" title="2. Vite 的要求"></a>2. Vite 的要求</h2><ol><li>Vite 要求项目完全由 ES Module 模块组成</li><li>common.js 模块不能直接在 Vite 上使用</li><li>打包上依旧还是使用 rollup 等传统打包工具</li></ol><h2 id="3-开发-Vite-解决的问题"><a href="#3-开发-Vite-解决的问题" class="headerlink" title="3. 开发 Vite 解决的问题"></a>3. 开发 Vite 解决的问题</h2><ol><li>第三方库的引入问题</li><li>对 CSS 资源的支持</li><li>.Vue 单文件的支持</li><li>对 TS 的支持</li></ol><h2 id="4-手写-Vite-第一部分（基础功能）"><a href="#4-手写-Vite-第一部分（基础功能）" class="headerlink" title="4. 手写 Vite 第一部分（基础功能）"></a>4. 手写 Vite 第一部分（基础功能）</h2><ol><li>前端起一个静态网站， 后端用 Koa 起一个服务</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在根目录下</span><br><span class="line">npm i koa -S</span><br><span class="line">mkdir index.js</span><br></pre></td></tr></table></figure><ol start="2"><li>引入 Koa，并起一个服务，监听 3000 端口</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; url, query &#125; = ctx.request</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;url:&#x27;</span> + url)</span><br><span class="line"><span class="comment">//  / =&gt; index.html</span></span><br><span class="line"><span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">ctx.type = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"><span class="comment">// 读取入口文件</span></span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ctx.body = content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *.js =&gt; src/*.js</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="string">&#x27;3000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;服务已启动在 3000 端口~&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当用户访问 3000 端口时，服务通过 <code>ctx.request</code> 获取到该文件根目录下的入口文件：<code>index.html</code>, 如何提供给用户？</p><ul><li><p>  判断 url === ‘/‘, 如果是的话，通过 node 自带的文件系统模块 <code>fs</code> 读取到当前目录下 index.html 文件的内容并通过 <code>ctx.body</code> 发送给用户</p></li><li><p>  我们将 main.js 中的 script 标签加上 <code>type=&quot;module&quot;</code> 属性，这样浏览器将按照 ES Module 的方式去请求文件，所以这个时候，浏览器会去请求 <code>./src/main.js</code>, 那我们又如何提供 js 文件给用户呢？</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; url, query &#125; = ctx.request</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;url:&#x27;</span> + url)</span><br><span class="line"><span class="comment">//  / =&gt; index.html</span></span><br><span class="line"><span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">ctx.type = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"><span class="comment">// 读取入口文件</span></span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ctx.body = content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *.js =&gt; src/*.js</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (url.endsWith(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">// /src/main.js =&gt; 代码文件所在位置/src/main.js</span></span><br><span class="line"><span class="comment">// 去掉 &#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">const</span> p = path.resolve(__dirname, url.slice(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line">ctx.body = content</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>  可以看到，我们判断当前请求的 url 是以 <code>.js</code> 结尾的文件，这时，我们使用 node 自带的路径模块 <code>path</code> 去读取当前根目录所在路径，并拼接上访问的路径。</p></li><li><p>  最后，通过 <code>ctx.body</code> 将 fs 获取到的 js 文件内容返回给用户。</p></li></ul><p>至此，已经能够支持基本的功能了，让我们接着完善它的功能~</p><h2 id="5-支持第三方库-此处用-Vue-示例"><a href="#5-支持第三方库-此处用-Vue-示例" class="headerlink" title="5. 支持第三方库 (此处用 Vue 示例)"></a>5. 支持第三方库 (此处用 Vue 示例)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue@next -S</span><br></pre></td></tr></table></figure><p>我们在 main.js 中使用 vue</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = &#123;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">// &lt;div&gt;&lt;div&gt;Hello, Vite!&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [h(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, <span class="built_in">String</span>(<span class="string">&#x27;Hello, Vite!&#x27;</span>))])</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以发现浏览器是会报错的，因为 from 的路径不合法，不是以 ‘.’ 或者 ‘/‘ 开头，所以该如何解决？</p><ul><li>  我们知道，在项目中引入第三方库，它会指向安装到本地的 node_modules 当中对应模块的代码，所以我们需要将 form 后面的路径转换一下，欺骗一下浏览器，让它变成合法的路径。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改写函数</span></span><br><span class="line"><span class="comment">// 需要改写，欺骗一下浏览器 &#x27;vue&#x27; =&gt; &#x27;/@modules&#x27; =&gt; 别名 (为了让前端认为是合法的路径)</span></span><br><span class="line"><span class="comment">// from &#x27;xxx&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rewriteImport</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">return</span> content.replace(<span class="regexp">/ from [&#x27;|&quot;]([^&#x27;&quot;]+)[&#x27;|&quot;]/g</span>, <span class="function">(<span class="params">s0, s1</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 判断不是一个绝对路径或相对路径</span></span><br><span class="line"><span class="keyword">if</span> (s1[<span class="number">0</span>] !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; s1[<span class="number">1</span>] !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">` from &#x27;/@modules/<span class="subst">$&#123;s1&#125;</span>&#x27;`</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s0</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>  我们将 ‘vue’ 通过 <code>正则</code> 转换为了 ‘/@modules/vue’，所以现在浏览器不会报错，然后我们继续往下，让它指向 node_modules 下面的 vue 模块。</p></li><li><p>我们在前面的基础上，加上一个 else if 分支，判断是否是以 ‘/@modules’ 开始的 url，如果是的话，则通过下面这几步，引入到 node_modules 对应的模块下：</p><ol><li>获取到 node_modules 下 vue 模块的路径，通过 <code>path.resolve()</code></li><li>通过 <code>require()</code> 获取到 vue 模块下的 package.json 的 module 属性</li><li>获取到 module 指向路径的绝对路径之后通过 <code>fs</code> 读取文件，返回给用户</li><li>这个时候我们去浏览器看看，可以正常获取到 vue 的相关文件，但是控制台报错 <code>缺少 process</code> 我们知道这是 node 环境的环境变量，所以我们需要在 最前面引入一个 script， 并自己定义一个 process 给它使用，所以我们需要在获取根目录文件的时候， 在 content 后面加上 一串代码，如下所示。</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; url, query &#125; = ctx.request</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;url:&#x27;</span> + url)</span><br><span class="line"><span class="comment">//  / =&gt; index.html</span></span><br><span class="line"><span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">ctx.type = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line"><span class="comment">// 读取入口文件</span></span><br><span class="line"><span class="keyword">let</span> content = fs.readFileSync(<span class="string">&#x27;./index.html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// 入口文件，加入环境变量</span></span><br><span class="line">content = content.replace(</span><br><span class="line"><span class="string">&#x27;&lt;script&#x27;</span>,</span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">window.process = &#123;env: &#123;NODE_ENV: &#x27;dev&#x27;&#125;&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script`</span></span><br><span class="line">)</span><br><span class="line">ctx.body = content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *.js =&gt; src/*.js</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (url.endsWith(<span class="string">&#x27;.js&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">// /src/main.js =&gt; 代码文件所在位置/src/main.js</span></span><br><span class="line"><span class="comment">// 去掉 &#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">const</span> p = path.resolve(__dirname, url.slice(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line">ctx.body = rewriteImport(content)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三方库的支持</span></span><br><span class="line"><span class="comment">// /@modules/vue =&gt; node_modules</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;/@modules&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">// /@modules/vue =&gt; 代码的位置/node_modules/vue 的 module 属性入口</span></span><br><span class="line"><span class="comment">// 引入到 node_modules/vue/ 的 es 模块入口</span></span><br><span class="line"><span class="comment">// 根据 vue 模块的 package.json 判断入口文件 module 属性</span></span><br><span class="line"><span class="keyword">const</span> prefix = path.resolve(__dirname, <span class="string">&#x27;node_modules&#x27;</span>, url.replace(<span class="string">&#x27;/@modules/&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载 vue 模块下的 package.json 文件的 module 属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = <span class="built_in">require</span>(prefix + <span class="string">&#x27;/package.json&#x27;</span>).module</span><br><span class="line"></span><br><span class="line"><span class="comment">// dist/vue.runtime.esm-bundler.js</span></span><br><span class="line"><span class="keyword">const</span> p = path.resolve(prefix, <span class="built_in">module</span>)</span><br><span class="line"><span class="keyword">const</span> ret = fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line">ctx.body = rewriteImport(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue =&gt; node_modules/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写函数</span></span><br><span class="line"><span class="comment">// 需要改写，欺骗一下浏览器 &#x27;vue&#x27; =&gt; &#x27;/@modules&#x27; =&gt; 别名 (为了让前端认为是合法的路径)</span></span><br><span class="line"><span class="comment">// from &#x27;xxx&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rewriteImport</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="keyword">return</span> content.replace(<span class="regexp">/ from [&#x27;|&quot;]([^&#x27;&quot;]+)[&#x27;|&quot;]/g</span>, <span class="function">(<span class="params">s0, s1</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 判断不是一个绝对路径或相对路径</span></span><br><span class="line"><span class="keyword">if</span> (s1[<span class="number">0</span>] !== <span class="string">&#x27;.&#x27;</span> &amp;&amp; s1[<span class="number">1</span>] !== <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">` from &#x27;/@modules/<span class="subst">$&#123;s1&#125;</span>&#x27;`</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s0</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到此，我们已经完成了对第三方库的支持！！</p><h2 id="6-Vue-单文件组件支持"><a href="#6-Vue-单文件组件支持" class="headerlink" title="6. Vue 单文件组件支持"></a>6. Vue 单文件组件支持</h2><ol><li>首先我们需要安装一下 vue 用来解析 template 模板的库</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue/compiler-sfc -s</span><br></pre></td></tr></table></figure><p>然后新件一个 vue 文件，引入到 main.js 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp, h &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>我们新增一个 else if 判断获取的 url 是否为 vue 文件，<br>然后分两步，第一步提取出 vue 文件的 script 部分，第二步提取出 template 并转换为 render 函数返回</p></li><li><p>通过 path 获取到 App.vue 的路径，读取其中的内容，并用 <code>compilerSfc.parse(fs.readFileSync(p, &#39;utf-8&#39;))</code> 获取到编译后的对象， 里面包含 script 和 template 的代码。</p></li><li><p>判断请求有没有携带上 <code>type=template</code> 的参数，如果没有，则走第一个分支：</p><ul><li><p>借用 vue 自带的 compile 框架， 解析单文件组件， 其实相当于 vue-loader 做的事情。</p></li><li><p>vue 分两步，再去加载 type=template 文件。</p></li><li><p>可以看到返回的是一个模板字符串，拿到之后，又会朝后端获取一个 template 文件，参数携带了 type，这个时候会走另一条。</p></li></ul></li><li><p>第二条分支， 将 template 模板通过 <code>compilerDom.compile(template.content, &#123; mode: &#39;module&#39; &#125;)</code> 转换为 render 函数并返回给用户。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支持单文件组件 SFC 组件</span></span><br><span class="line"><span class="comment">// *.vue =&gt;</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (url.indexOf(<span class="string">&#x27;.vue&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 第一步： vue 文件 =&gt; template script</span></span><br><span class="line"><span class="keyword">const</span> p = path.resolve(__dirname, url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>].slice(<span class="number">1</span>)) <span class="comment">// 得到 app.vue 的目录</span></span><br><span class="line"><span class="keyword">const</span> ret = compilerSfc.parse(fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ret:&#x27;</span> + ret)</span><br><span class="line"><span class="keyword">const</span> &#123; descriptor &#125; = ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!query.type) &#123;</span><br><span class="line"><span class="comment">// ret.descriptor.script 提取 js 部分 + (template模板生成) render 函数</span></span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line"><span class="comment">// 借用 vue 自带的 compile 框架， 解析单文件组件， 其实相当于 vue-loader 做的事情</span></span><br><span class="line"><span class="comment">// vue 分两步，再去加载 type=template 文件</span></span><br><span class="line">ctx.body = <span class="string">`<span class="subst">$&#123;rewriteImport(descriptor.script.content.replace(<span class="string">&#x27;export default &#x27;</span>, <span class="string">&#x27;const __script = &#x27;</span>))&#125;</span></span></span><br><span class="line"><span class="string">import &#123; render as __render&#125; from &quot;<span class="subst">$&#123;url&#125;</span>?type=template&quot;</span></span><br><span class="line"><span class="string">__script.render = __render</span></span><br><span class="line"><span class="string">export default __script</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 第二步：template 模板 =&gt; render函数</span></span><br><span class="line"><span class="keyword">const</span> template = descriptor.template</span><br><span class="line"><span class="keyword">const</span> render = compilerDom.compile(template.content, &#123; <span class="attr">mode</span>: <span class="string">&#x27;module&#x27;</span> &#125;)</span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;render:&#x27;</span> + render)</span><br><span class="line">ctx.body = rewriteImport(render.code)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，页面上已经展示成功！！能够支持单文件组件！</p><h2 id="7-支持-CSS-文件"><a href="#7-支持-CSS-文件" class="headerlink" title="7. 支持 CSS 文件"></a>7. 支持 CSS 文件</h2><ol><li>在 src 下新增 index.css</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>新增 else if 分支，判断当前请求文件为 css 文件，获取到该路径，然后用 fs 读取文件。</p></li><li><p>使用 content 变量，用模板字符串实现，创建 style 标签， 添加 type 属性， 挂载到 head 下，将 css 的内容赋值给 innerHTML，最后通过 ctx.body 返回</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析 CSS</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (url.endsWith(<span class="string">&#x27;.css&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">const</span> p = path.resolve(__dirname, url.slice(<span class="number">1</span>))</span><br><span class="line"><span class="keyword">const</span> file = fs.readFileSync(p, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">// css 转换为 js 代码</span></span><br><span class="line"><span class="comment">// 利用 JS 添加一个 style 标签</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="string">`</span></span><br><span class="line"><span class="string">const css = &quot;<span class="subst">$&#123;file.replace(<span class="regexp">/\s/g</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line"><span class="string">let link = document.createElement(&#x27;style&#x27;)</span></span><br><span class="line"><span class="string">link.setAttribute(&#x27;type&#x27;, &#x27;text/css&#x27;)</span></span><br><span class="line"><span class="string">document.head.appendChild(link)</span></span><br><span class="line"><span class="string">link.innerHTML = css</span></span><br><span class="line"><span class="string">export default css</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">ctx.type = <span class="string">&#x27;application/javascript&#x27;</span></span><br><span class="line">ctx.body = content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，简易版 Vite 已经完成！！！</p>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统前置基础知识</title>
      <link href="/Hexo-Blog/2022/11/23/chrome/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/Hexo-Blog/2022/11/23/chrome/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统前置基础知识"><a href="#操作系统前置基础知识" class="headerlink" title="操作系统前置基础知识"></a>操作系统前置基础知识</h1><blockquote><p>计算机的三层架构：机器硬件在最底层，操作系统在中间，应用在最上面。</p></blockquote><p><img src="https://camo.githubusercontent.com/cefdb8f3af9d02523d297a536f1354cc10c3f011de367f715990f89b86f3530c/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f3136343439352f313631343530383232313435332d37323133346135302d643463372d343230372d616237312d3933643161663635623233612e706e6723616c69676e3d6c65667426646973706c61793d696e6c696e65266865696768743d333134266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d6370752e706e67266f726967696e4865696768743d333134266f726967696e57696474683d3539332673697a653d3737313935267374617475733d646f6e65267374796c653d6e6f6e652677696474683d353933"></p><p>在学习浏览器架构之前，我们先来了解一下前置的一些操作系统的基础知识，包括 CPU、GPU、进程、线程 等。</p><h3 id="1-CPU（Central-Processing-Unit）"><a href="#1-CPU（Central-Processing-Unit）" class="headerlink" title="1. CPU（Central Processing Unit）"></a>1. CPU（Central Processing Unit）</h3><blockquote><p>CPU（中央处理单元）就是芯片，是作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元。</p></blockquote><h5 id="N1-CPU-可以被认为是你的计算机的大脑"><a href="#N1-CPU-可以被认为是你的计算机的大脑" class="headerlink" title="N1: CPU 可以被认为是你的计算机的大脑"></a>N1: CPU 可以被认为是你的计算机的大脑</h5><p>其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。</p><p>一个 CPU 核心，在这里被描绘成一个办公室工作人员，可以在许多不同的任务进来时一项一项地处理它们。它可以处理从计算到渲染的一切事情，同时知道如何回复访问者的行为。</p><p>在过去，大多数 CPU 是一个单一的芯片。在现代硬件中，通常会有一个以上的核心，给你的手机和笔记本电脑带来更多的计算能力。</p><h5 id="N2-CPU-的工作原理"><a href="#N2-CPU-的工作原理" class="headerlink" title="N2: CPU 的工作原理"></a>N2: CPU 的工作原理</h5><p>冯诺依曼体系结构是现代计算机的基础。在该体系结构下，程序和数据统一存储，指令和数据需要从同一存储空间存取，经由同一总线传输，无法重叠执行。根据冯诺依曼体系，CPU的工作分为以下 5 个阶段：取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回。</p><ul><li><p>取指令（IF，instruction fetch），即将一条指令从主存储器中取到指令寄存器的过程。程序计数器中的数值，用来指示当前指令在主存中的位置。当 一条指令被取出后，程序计数器（PC）中的数值将根据指令字长度自动递增。</p></li><li><p>指令译码阶段（ID，instruction decode），取出指令后，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类 别以及各种获取操作数的方法。现代CISC处理器会将拆分已提高并行率和效率。</p></li><li><p>执行指令阶段（EX，execute），具体实现指令的功能。CPU的不同部分被连接起来，以执行所需的操作。</p></li><li><p>访存取数阶段（MEM，memory），根据指令需要访问主存、读取操作数，CPU得到操作数在主存中的地址，并从主存中读取该操作数用于运算。部分指令不需要访问主存，则可以跳过该阶段。 </p></li><li><p>结果写回阶段（WB，write back），作为最后一个阶段，结果写回阶段把执行指令阶段的运行结果数据“写回”到某种存储形式。结果数据一般会被写到CPU的内部寄存器中，以便被后续的指令快速地存取；许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。</p></li></ul><p>在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就从程序计数器中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。 [1]  许多复杂的CPU可以一次提取多个指令、解码，并且同时执行。</p><h5 id="N3-CPU-的调度算法（待补充）"><a href="#N3-CPU-的调度算法（待补充）" class="headerlink" title="N3: CPU 的调度算法（待补充）"></a>N3: CPU 的调度算法（待补充）</h5><hr><h3 id="2-GPU-（Graphics-Processing-Unit）"><a href="#2-GPU-（Graphics-Processing-Unit）" class="headerlink" title="2. GPU （Graphics Processing Unit）"></a>2. GPU （Graphics Processing Unit）</h3><h5 id="N1-GPU-简介"><a href="#N1-GPU-简介" class="headerlink" title="N1: GPU 简介"></a>N1: GPU 简介</h5><p>图形处理器又称显示核心、视觉处理器、显示芯片，是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上做图像和图形相关运算工作的微处理器。</p><p>一个光栅显示系统离不开图形处理器，图形处理器是图形系统结构的重要元件，是连接计算机和显示终端的纽带。</p><p>应该说有显示系统就有图形处理器 (俗称显卡)，但是早期的显卡只包含简单的存储器和帧缓冲区，它们实际上只起了一个图形的存储和传递作用，一切操作都必须由 CPU 来控制。</p><p>这对于文本和一些简单的图形来说是足够的，但是当要处理复杂场景特别是一些真实感的三维场景，单靠这种系统是无法完成任务的。所以后来发展的显卡都有图形处理的功能。它不单单存储图形，而且能完成大部分图形功能，这样就大大减轻了 CPU 的负担，提高了显示能力和显示速度。</p><p>随着电子技术的发展，显卡技术含量越来越高，功能越来越强，许多专业的图形卡已经具有很强的3D处理能力，而且这些3D图形卡也渐渐地走向个人计算机。一些专业显卡具有的晶体管数甚至比同时代的 CPU 的晶体管数还多。比如2000年加拿大ATI公司推出的 RADEON 显卡芯片含有3千万颗晶体管，达到每秒15亿个像素填写率。</p><h5 id="N2-CPU-和-GPU-的区别？"><a href="#N2-CPU-和-GPU-的区别？" class="headerlink" title="N2: CPU 和 GPU 的区别？"></a>N2: CPU 和 GPU 的区别？</h5><p>CPU 和 GPU 之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU 需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。这些都使得 CPU 的内部结构异常复杂。而 GPU 面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。</p><hr><h3 id="3-什么是进程？"><a href="#3-什么是进程？" class="headerlink" title="3. 什么是进程？"></a>3. 什么是进程？</h3><blockquote><p>进程是系统进行 <strong>资源分配</strong> 的最小单位</p></blockquote><ul><li><p>进程可以看作应用的执行程序。线程是存在于进程里面，并且可以执行进程的任一部分程序。</p></li><li><p>当我们启动一个应用的时候，就会创建一个进程。程序可能会创建多个线程去帮助其工作，当然这是可选的。操作系统会给进程分配内存块，应用程序的所有状态都可以保存在该私有空间。当关闭程序的时候，进程会消失并且操作系统也会释放内存。</p></li><li><p>一个进程可以向操作系统申请另外一个进程来执行不同的任务，操作系统将为新进程分配另外一部分内存。如果两个进程想要通信，他们需要使用 Inter Process Communication （进程间通信）。很多应用都是以这种方式 工作的，如果一个进程无响应，可以直接重启该进程，而不需要停止执行应用程序其他部分的进程。</p></li></ul><h5 id="N1-为什么要有进程？"><a href="#N1-为什么要有进程？" class="headerlink" title="N1: 为什么要有进程？"></a>N1: 为什么要有进程？</h5><p>对于计算机的使用者来说，会通过运行的程序来完成种种任务。而“程序，是为了实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。” 用大白话来说，程序就是告诉计算机怎样一步步地完成我们交给它的任务。</p><p>既然程序要运行，要完成某种任务，那么怎样完成，需要什么资源进行协助，这是必然要面对的问题。进而在此之上抽象出了“进程“的概念。“进程是资源分配的最小单位”这个常用的概念能贴切地说明一些情况。试想一下，如果各个要运行的程序，对所涉及的资源没有被管理、隔离、保护，势必会出乱子。联想到个人的资产，如果可以被他人随意地获取、使用，也就会带来各式各样的问题。而资源，就是程序的“资产”。</p><p>进程的出现，不仅仅解决了资源分配的为题，还解决了另一个重要问题，并发———使 CPU 资源能够充分地被利用。</p><p>程序的运行离不开 CPU 的参与，进程作为程序的抽象自然也需要。因而引出一个概念，“每个进程都有自己的虚拟 CPU ”。是的，进程都认为 CPU 就应该是自己的，都想尽可能地运行足够多的时间。但是 CPU 只有一个或者若干个，进程可以有更多个，因此不管是单 CPU 还是多 CPU，面对的都是“如何将特有资源分配给更多需求者使用”的问题。此后文章就取单核 CPU的情况来看，足以说明问题，也能简化问题。</p><p>CPU 由谁来使用，就成了必须面对的问题，由此引出了“进程间如何进行调度”的问题，所以进程也是进行调度的独立单位。CPU 被视为一种资源，按照某种规则，让不同的进程可以在特定的时机占用。有时候，不同的进程间还可以拥有其他的共同资源，就像人可以拥有共同资产一样。既然涉及到了共同资源，那么各方希望就会对这份资源的变动保持敏感，希望能得知这份共同资源的真实变动信息。因此引出了另一个问题，“进程间的通信”问题，即资源或数据的变动，在各种情况下保持正确性。</p><p>针对这两个问题，下文会针对性地做梳理，这里不妨先了解进程是什么样子。</p><h5 id="N2-进程小-demo"><a href="#N2-进程小-demo" class="headerlink" title="N2: 进程小 demo"></a>N2: 进程小 demo</h5><p>“小明，18岁，185cm，在球场上打球”，与人一样，进程有自己的样子与正在做的事情，操作系统维护着一份表格来描述这份信息，这张表格即为进程表。每个进程占用一个进程表，表里有各种字段来表示不同的信息。大致分为三类信息，进程管理、存储管理、文件管理。其中：</p><ul><li><p>进程管理包括：寄存器、程序计数器、程序状态字、堆栈指针、进程状态、优先级、调度参数、进程ID、父进程、进程组、信息、进程开始时间、使用CPU的时间、子进程的CPU时间、下次定时器时间等。</p></li><li><p>存储管理包括：正文段指针、数据段指针、堆栈段指针。</p></li><li><p>文件管理包括：根目录、工作目录、文件描述符、用户ID、组ID。</p></li></ul><p>与此同时，每个进程还拥有自己的内存地址空间以可以对各类数据进行操作，一般而言，进程之间是 <strong>不可以访问对方的内存地址空间的。</strong> 这就像人的房子，其他人不能随便的访问，往自己的房子里增添物件也只是个人的事。<br>有了这些信息，进程就有了轮廓，操作系统才可能正确地调度运行这些进程，完成并发。</p><p>并发，即使指在一段时间内，有若干事情在进行，但在任一时刻，仅有一件事情在进行。区别于并行，并行则为某一时刻，可以有若干事情在进行。如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af24780cb0f44bb9a3896ed085bb027d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><p>在多 CPU 的情况下，能够实现一定范围的内并行，但更多时候，以并发来看进程的执行更加合适。</p><p>并发所解决的问题无疑是必要的。日常工作中，挂着音乐听着歌，开着微信聊着天，后台还运行着邮箱等着邮件的到来，这些运行的程序是各式各样进程在进行并发。试想一下，如果没有并发，使用某个程序的时候其他的程序就不能被使用，会发生什么。聊天的时候不能听歌，听歌的时候不能工作，等邮箱的时候就只能干巴巴地等着。效率低下，又不愉快。</p><p>实际上，很多进程更多的时候是在等待一些条件如  <a href="https://zh.m.wikipedia.org/zh-cn/I/O">I/O</a> 等才能继续进行下一步，真正需要执行的地方需要时间很短，如果在等待的时间还要占用 CPU，则白白浪费了 CPU 资源。就像一个邮件程序，可以几十秒甚至几分钟去检查一下有没有新的邮件即可，相比于等待邮件到来的时间，“检查”这一操作需要的时间非常短，也因此只要在特定的规律时间内让它占用一下 CPU 即可。</p><p>当有很多类似的进程时，并发就能让更多的进程在一段时间内做更多的事情。</p><p>并发释放了CPU的劳动力，让更多进程能参与使用，提高了CPU的利用率。CPU利用率 = 1 - p^n， 其中p为进程等待条件的时间/使用CPU的时间，n为进程数，此公式可仅做了解。</p><h5 id="N3-进程的状态-待补充"><a href="#N3-进程的状态-待补充" class="headerlink" title="N3: 进程的状态 (待补充)"></a>N3: 进程的状态 (待补充)</h5><h5 id="N3-进程的创建、终止、层次结构-待补充"><a href="#N3-进程的创建、终止、层次结构-待补充" class="headerlink" title="N3: 进程的创建、终止、层次结构 (待补充)"></a>N3: 进程的创建、终止、层次结构 (待补充)</h5><h5 id="N4-进程死锁"><a href="#N4-进程死锁" class="headerlink" title="N4: 进程死锁"></a>N4: 进程死锁</h5><blockquote><p>什么是死锁：不允许两个或多个进程同时占用，若不能采取其他措施，这种循环等待状况会无线持续下去，就发生进程死锁。</p></blockquote><p>产生死锁的的必要条件</p><ul><li><p>互斥条件：某个资源在一段时间内只能由一个进程占用，不能同时被两个或两个以上的进程占有。</p></li><li><p>不可抢占条件：进程所获得的资源在未使用完毕之前，资源申请者不能强行从资源占有者手中夺取，只能由该资源的占有者自行释放。</p></li><li><p>占有申请条件：进程至少已经占有一个资源，但又申请新的资源，但申请的资源已被另外的进程占有，此时该进程阻塞；但他在等待新资源时，还在占用已占有的资源。</p></li><li><p>循环等待条件：存在一个进程等待序列{p1,p2,…pn},p1等待P2占有资源，P2等待P3占用资源，…..,而Pn等待p1占用资源，这样形成一个进程等待循环。</p></li></ul><p>如何预防死锁？(待补充)</p><hr><h3 id="4-什么是线程？"><a href="#4-什么是线程？" class="headerlink" title="4. 什么是线程？"></a>4. 什么是线程？</h3><blockquote><p>线程是操作系统能够进行 <strong>调度的</strong> 最小单位。它被包含在进程之中，是进程中的 实际运作单位</p></blockquote><h5 id="N1-为什么要有线程"><a href="#N1-为什么要有线程" class="headerlink" title="N1: 为什么要有线程?"></a>N1: 为什么要有线程?</h5><p>有了进程之后，程序已能如期运行，那为什么何还要有线程呢。试想一下，当需要使用共同的资源，并通过若干个可同时进行的事件共同达成某个任务时，如果使用进程间进行合作，会很复杂与困难，因为进程的设计，希望资源是自己的，别的进程不能轻易访问。</p><p>线程的出现，使这样的问题迎刃而解。就和写代码一样，完成了解耦，也就是将程序的资源管理与执行隔离开来，线程就是负责执行的。所以，“线程是调度和分配的最小单位”。如同大家处于同一个小组，小组如同进程，大家拥有共同的资源，当一起执行某个任务时，A负责冲锋陷阵，B负责后勤… 这即是将执行分开的由来。</p><p>线程除了访问共同资源简单，分离了执行之外，另一个有点是更轻量级。通过某些手段，进程间也能在使用共同资源的情况下合作某个任务，但是进程的创建、切换更消耗时间。在许多系统中，可达到10 ～ 100倍。无论进程、线程，他们的运行都需要CPU的参与，当进程间需要相互切换时，将发生系统调用。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/359b86ba3a92440c94d9a9750f09d01d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><p>系统调用为发生了从 用户态 -&gt; 内核态 -&gt; 用户态 的过程，我们的程序运行在用户态，但有些时候需要借助系统提供的服务才能进行某项事务，就要通过系统调用从用户态进入内核态，继而进行这项事务。完成之后，再从内核态回到用户态，继续运行我们的程序。从用户态到内核态，需要暂停当前用户态的执行，然后存储上下文，对于用户态发来的系统调用，内核态是不信任的，因此需要做各项的检查。内核态执行完之后，再回复之前存储的上下文，回到用户态继续执行。</p><p>对于进程间的切换来说，最重要的耗时部分，就在于切换上下文。进程模型抽象出了进程的虚拟地址空间，进程间的虚拟地址空间的切换，会发生页表查找，而页表查找，是一个很慢的过程。</p><p>线程间的切换则轻量得多（指同一进程内的）。其中的区别就像，你在自己的房子里，在客厅看电视，然后去厨房倒了一杯水， 与从你家，走到你的朋友家讨杯水喝的区别。</p><hr><h3 id="5-进程和线程引入的问题？"><a href="#5-进程和线程引入的问题？" class="headerlink" title="5. 进程和线程引入的问题？"></a>5. 进程和线程引入的问题？</h3><p>前文有提到过，进程需要 CPU 的参与以及访问公共资源，对于进程来说的共享资源比如某些公用的文件，希望使用的 I/0 设备如打印机等。这就涉及到了两个重要的问题需要处理：</p><ul><li>CPU 的分配，也就是如何进行调度，即某一时间，由谁来使用 CPU。</li><li>通信问题，当使用共享资源时，需要知道它的真实状态，如果按照资源的过时信息进行使用，将使程序进入异常状态</li></ul><p>线程与进程面对的问题，是相似的。</p><h5 id="N1-如何解决进程间的通信问题？-待补充"><a href="#N1-如何解决进程间的通信问题？-待补充" class="headerlink" title="N1: 如何解决进程间的通信问题？(待补充)"></a>N1: 如何解决进程间的通信问题？(待补充)</h5><h5 id="N2-如何解决资源分配问题？-待补充"><a href="#N2-如何解决资源分配问题？-待补充" class="headerlink" title="N2: 如何解决资源分配问题？(待补充)"></a>N2: 如何解决资源分配问题？(待补充)</h5>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 基础篇(一)</title>
      <link href="/Hexo-Blog/2022/11/23/ts/TypeScript%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%80)/"/>
      <url>/Hexo-Blog/2022/11/23/ts/TypeScript%E5%9F%BA%E7%A1%80%E7%AF%87(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-基础篇（一）"><a href="#TypeScript-基础篇（一）" class="headerlink" title="TypeScript 基础篇（一）"></a>TypeScript 基础篇（一）</h1><h3 id="1-TS-4-种特殊类型"><a href="#1-TS-4-种特殊类型" class="headerlink" title="1. TS 4 种特殊类型"></a>1. TS 4 种特殊类型</h3><ul><li>never 代表不可达，比如函数抛异常的时候，返回值就是 never。</li><li>void 代表空，可以是 undefined 或 never。</li><li>any 是任意类型，任何类型都可以赋值给它，它也可以赋值给任何类型（除了 never）。</li><li>unknown 是未知类型，任何类型都可以赋值给它，但是它不可以赋值给别的类型。</li></ul><h5 id="N1-any-和-unknown-的使用场景？"><a href="#N1-any-和-unknown-的使用场景？" class="headerlink" title="N1: any 和 unknown 的使用场景？"></a>N1: any 和 unknown 的使用场景？</h5><blockquote><p>any 和 unknown 的最大区别是, unknown 是 top type (任何类型都是它的 subtype) , 而 any 即是 top type, 又是 bottom type (它是任何类型的 subtype ) ,这导致 any 基本上就是放弃了任何类型检查.</p></blockquote><blockquote><p>使用 unknown 可以保证类型安全，使用 any 则彻底放弃了类型检查</p></blockquote><h5 id="N2-unknown"><a href="#N2-unknown" class="headerlink" title="N2: unknown"></a>N2: unknown</h5><p>TypeScript 3.0中引入的 unknown 类型也被认为是 top type ，但它更安全。与 any 一样，所有类型都可以分配给unknown。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uncertain: unknown = <span class="string">&#x27;Hello&#x27;</span>!;</span><br><span class="line">uncertain = <span class="number">12</span>;</span><br><span class="line">uncertain = &#123; <span class="attr">hello</span>: <span class="function">() =&gt;</span> <span class="string">&#x27;Hello!&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>我们只能将 unknown 类型的变量赋值给 any 和 unknown。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uncertain: unknown = <span class="string">&#x27;Hello&#x27;</span>!;</span><br><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = uncertain;</span><br></pre></td></tr></table></figure><p>它确实在很多方面不同于 any 类型。如果不缩小类型，就无法对 unknown 类型执行任何操作。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">&#x27;22&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog: unknown = getDog();</span><br><span class="line">dog.hello(); <span class="comment">//Object is of type &#x27;unknown&#x27;</span></span><br><span class="line">缩小类型例子</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isTrue = (tar: obj1 | obj2):tar is obj1 =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (tar <span class="keyword">as</span> obj1).name !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">tar: obj1 | obj2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isTrue(tar) ? tar.name : tar.age</span><br><span class="line">    <span class="comment">// 如果是 obj1 返回 name 反之返回 obj2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tar1: obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> tar2: obj2 = &#123;<span class="attr">age</span>: <span class="number">2</span>&#125;</span><br><span class="line">handle(tar1)    <span class="comment">// &#x27;a&#x27;</span></span><br><span class="line">handle(tar2)    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>实际开发使用场景：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = user.id <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="built_in">string</span><span class="comment">// 后端返回的 user.id 是 number</span></span><br></pre></td></tr></table></figure><h5 id="N3-any"><a href="#N3-any" class="headerlink" title="N3: any"></a>N3: any</h5><p>多使用于接口返回的数据或实在不知道类型的函数参数。</p><hr><h3 id="2-type-和-interface-的区别？"><a href="#2-type-和-interface-的区别？" class="headerlink" title="2. type 和 interface 的区别？"></a>2. type 和 interface 的区别？</h3><blockquote><p>TS 官方给出的解释: Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.<br><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces">https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces</a><br>类型别名和接口非常相似，在很多情况下你可以在它们之间自由选择。几乎所有接口的功能都可以在类型中使用，关键的区别在于，类型不能被重新打开以添加新的属性，而接口则总是可以扩展的..</p></blockquote><p>个人认为主要是用法上的区别，语义上的区别不大。</p><h5 id="N1-相同点"><a href="#N1-相同点" class="headerlink" title="N1: 相同点"></a>N1: 相同点</h5><p>都可以描述一个对象或者函数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="keyword">interface</span>--&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SetUser &#123;</span><br><span class="line">  (name: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="keyword">type</span>--&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SetUser = <span class="function">(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">void</span>;  </span><br></pre></td></tr></table></figure><p>都允许拓展（extends）</p><p>interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--<span class="keyword">interface</span> <span class="keyword">extends</span> <span class="keyword">interface</span>--&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="keyword">type</span> <span class="keyword">extends</span> <span class="keyword">type</span>--&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="keyword">interface</span> <span class="keyword">extends</span> type--&gt;</span><br><span class="line"></span><br><span class="line">type Name = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--<span class="keyword">type</span> <span class="keyword">extends</span> <span class="keyword">interface</span>--&gt;</span><br><span class="line"><span class="keyword">interface</span> Name &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; </span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="N2-不同点"><a href="#N2-不同点" class="headerlink" title="N2: 不同点"></a>N2: 不同点</h5><p>type 可以而 interface 不行</p><ul><li>type 可以声明基本类型别名，联合类型，元组等类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure><ul><li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当你想获取一个变量的类型时，使用 typeof</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">type</span> B = <span class="keyword">typeof</span> div</span><br></pre></td></tr></table></figure><ul><li>其它操作</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | <span class="built_in">number</span>;  </span><br><span class="line"><span class="keyword">type</span> Text = <span class="built_in">string</span> | &#123; <span class="attr">text</span>: <span class="built_in">string</span> &#125;;  </span><br><span class="line"><span class="keyword">type</span> NameLookup = Dictionary&lt;<span class="built_in">string</span>, Person&gt;;  </span><br><span class="line"><span class="keyword">type</span> Callback&lt;T&gt; = <span class="function">(<span class="params">data: T</span>) =&gt;</span> <span class="built_in">void</span>;  </span><br><span class="line"><span class="keyword">type</span> Pair&lt;T&gt; = [T, T];  </span><br><span class="line"><span class="keyword">type</span> Coordinates = Pair&lt;<span class="built_in">number</span>&gt;;  </span><br><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = T | &#123; <span class="attr">left</span>: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure><p>interface 可以而 type 不行</p><ul><li>interface 能够声明合并</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">User 接口为 &#123;</span></span><br><span class="line"><span class="comment">  name: string</span></span><br><span class="line"><span class="comment">  age: number</span></span><br><span class="line"><span class="comment">  sex: string </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="N3-总结"><a href="#N3-总结" class="headerlink" title="N3: 总结"></a>N3: 总结</h5><p>用 interface 描述 <strong>数据结构</strong>，用 type 描述 <strong>类型关系</strong></p><hr><h3 id="3-What…"><a href="#3-What…" class="headerlink" title="3. What…"></a>3. What…</h3>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 小点总结</title>
      <link href="/Hexo-Blog/2022/11/22/ts/TypeScript%E5%B0%8F%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/Hexo-Blog/2022/11/22/ts/TypeScript%E5%B0%8F%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-小点归纳总结"><a href="#TypeScript-小点归纳总结" class="headerlink" title="TypeScript 小点归纳总结"></a>TypeScript 小点归纳总结</h1><h3 id="1-ts-expect-error"><a href="#1-ts-expect-error" class="headerlink" title="1. @ts-expect-error"></a>1. @ts-expect-error</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) =&gt;</span> a+b; </span><br><span class="line">multiply(<span class="string">&#x27;12&#x27;</span>,<span class="number">13</span>); </span><br></pre></td></tr></table></figure><p>TS 编译器会提示报错：Argument of type ‘string’ is not assignable to parameter of type你不能修改第一个参数的类型，并且暂时想要忽略 TS 编译器报出的错误，就可以用 @ts-ignore 来抑制错误。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) =&gt;</span> a*b; </span><br><span class="line"><span class="comment">// @ts-ignore </span></span><br><span class="line">multiply(<span class="string">&#x27;12&#x27;</span>,<span class="number">13</span>); </span><br></pre></td></tr></table></figure><p>当你修复了错误，并将传给 multiply 函数的第一个参数 ‘12’ 改为 12 后：</p><p>千万别忘了把我们之前使用的 @ts-ignore 指令删除，因为它会永远忽略下一行，除非你把它删掉，否则将来可能会导致代码出现错误。</p><p>如果担心自己忘记删除，也可以用 @ts-expect-error 指令，它与 @ts-ignore 指令类似，不同的是一旦错误被修复，TS 编译器就会提示报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) =&gt;</span> a+b; </span><br><span class="line"><span class="comment">// @ts-expect-error </span></span><br><span class="line">multiply(<span class="number">12</span>,<span class="number">13</span>); </span><br><span class="line">Unused <span class="string">&#x27;@ts-expect-error&#x27;</span> directive.</span><br></pre></td></tr></table></figure><p>这样能够提醒你在修复错误后立即删除指令。</p><hr><h3 id="2-never-类型"><a href="#2-never-类型" class="headerlink" title="2. never 类型"></a>2. never 类型</h3><p>假设有一个接受错误状态码并根据状态抛出错误的函数，在这种情况下，当 function 不会正常结束时，never 类型就派上用场了。</p><p>never 和 void 之间的区别是：void 意味着至少要返回一个 undefined 或 null，而 never 意味着不会正常执行到函数的终点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwError</span>(<span class="params">error: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(error);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><h3 id="3-模板文字类型"><a href="#3-模板文字类型" class="headerlink" title="3. 模板文字类型"></a>3. 模板文字类型</h3><p>模板文字类型类似于 javascript 中的字符串类型，但是特定于类型。假设你想实现一个弹出框的库，并且有一个用于定位弹出框的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> popoverPositions = <span class="string">&#x27;top&#x27;</span>|<span class="string">&#x27;bottom&#x27;</span>|<span class="string">&#x27;left&#x27;</span>|<span class="string">&#x27;right&#x27;</span>|<span class="string">&#x27;top-left&#x27;</span>|<span class="string">&#x27;top-right&#x27;</span>|<span class="string">&#x27;top-center&#x27;</span>|<span class="string">&#x27;bottom-left&#x27;</span>|<span class="string">&#x27;bottom-right&#x27;</span>|<span class="string">&#x27;bottom-center&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但是在实际使用中，对这些类型进行排列组合会让你抓狂。</p><p>通过使用模板字面量类型，你可以很方便的进行分解并组合类型，这样就可以得倒包含所有可能组合出的新类型了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> positions = <span class="string">&#x27;top&#x27;</span>|<span class="string">&#x27;bottom&#x27;</span>|<span class="string">&#x27;center&#x27;</span>; </span><br><span class="line"><span class="keyword">type</span> directions = <span class="string">&#x27;left&#x27;</span>|<span class="string">&#x27;right&#x27;</span>|<span class="string">&#x27;center&#x27;</span> </span><br><span class="line"><span class="keyword">type</span> popoverPositions = positions | directions | <span class="string">`<span class="subst">$&#123;positions&#125;</span>-<span class="subst">$&#123;directions&#125;</span>`</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-空断言"><a href="#4-空断言" class="headerlink" title="4. 空断言"></a>4. 空断言</h3><p>空断言用来告诉 TS 编译器你的值既不是 null 也不是 undefined。假设已经把值初始化为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber:<span class="literal">null</span> | <span class="built_in">number</span> = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure><p>假设我们有一个只接受 number 类型的函数，</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line">add(myNumber,<span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>这时编译器会报错：Argument of type ‘null’ is not assignable to parameter of type ‘number’.所以在这里，可以在变量末尾使用带有 ! 的空断言，告诉编译器传入的值不为空。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line">add(myNumber!,<span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>上面的代码能够编译成功。</p><hr><h3 id="5-Record"><a href="#5-Record" class="headerlink" title="5. Record"></a>5. Record</h3><p>Record是一个很好用的工具类型。</p><p>他会将一个类型的所有属性值都映射到另一个类型上并创造一个新的类型, 先看看·它的源码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a type with a set of properties K of type T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好像源码也比较简单，即将K中的每个属性([P in K]),都转为T类型。常用的格式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> proxyKType = Record&lt;K,T&gt;</span><br></pre></td></tr></table></figure><p>会将K中的所有属性值都转换为T类型，并将返回的新类型返回给proxyKType，K可以是联合类型、对象、枚举…</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">type</span> petsGroup = <span class="string">&#x27;dog&#x27;</span> | <span class="string">&#x27;cat&#x27;</span> | <span class="string">&#x27;fish&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IPetInfo &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPets = Record&lt;petsGroup | <span class="string">&#x27;otherAnamial&#x27;</span>, IPetInfo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animalsInfo:IPets = &#123;</span><br><span class="line">    <span class="attr">dog</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;dogName&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">cat</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;catName&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">fish</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;fishName&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">otherAnamial</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;otherAnamialName&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 在 <code>type IPets = Record&lt;petsGroup | ‘otherAnamial’, IPetInfo&gt;</code> 中除了petsGroup的值之外，还追加了 ‘otherAnamial’ 这个值。</p><h5 id="N1-Record-类型-Vs-索引签名"><a href="#N1-Record-类型-Vs-索引签名" class="headerlink" title="N1: Record 类型 Vs 索引签名"></a>N1: Record 类型 Vs 索引签名</h5><p>在 TypeScript 中，我们访问带有方括号的对象的方式称为索引签名。 它广泛用于具有未知字符串键和特定值的对象类型。下面是一个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> studentScore = &#123; [ name:<span class="built_in">string</span>]:<span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure><p>上面的索引签名示例也可以使用 Record 类型表示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> studentScore = Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure><p>对于这个用例，从类型断言的角度看，这两种类型的声明的作用是一致的。从语法的角度看，索引签名是更好些，因为其中的name 的键表达式更清晰的表达了它的意图，并在vscode的展示中更智能感知。</p><p>所以，为什么我们要去使用Record类型呢？</p><h5 id="N2-为什么Record-类型有用？"><a href="#N2-为什么Record-类型有用？" class="headerlink" title="N2: 为什么Record 类型有用？"></a>N2: 为什么Record 类型有用？</h5><p>Record类型的好处是简明的。当我们想要去限制属性时，也就是Record类型大显身手的时候。<br>下面的示例是我们在Record中使用联合字符串去限制属性键:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> roles = <span class="string">&#x27;tester&#x27;</span> | <span class="string">&#x27;developer&#x27;</span> | <span class="string">&#x27;manager&#x27;</span></span><br><span class="line"><span class="keyword">const</span> staffCount: Record&lt;roles, <span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">tester</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">developer</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">manager</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个有用的功能是 keys 可以是枚举。在下面的例子中，我们使用 staffTypes 枚举作为 Record 类型的限制值，因此可读性更好。请注意，尽在 TypeScript2.9 之后才支持枚举。因此，在2.9版本之前，key 的类型被限制为 string 类型。</p><h5 id="N3-Record-类型和-keyof-组合"><a href="#N3-Record-类型和-keyof-组合" class="headerlink" title="N3: Record 类型和 keyof 组合"></a>N3: Record 类型和 keyof 组合</h5><p>通过使用keyof从现有类型中获取所有的属性，并和字符串组合，我们可以做如下事情：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Staff &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> StaffJson = Record&lt;keyof Staff, <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> product: StaffJson = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">    <span class="attr">salary</span>: <span class="string">&#x27;3000&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想要保留现有类型的属性但将值类型转换为其他类型时，这很便捷。</p><p>Record 是一个有用和简要的工具类型，可以让你的代码更健壮。</p><hr><h3 id="6-What"><a href="#6-What" class="headerlink" title="6. What"></a>6. What</h3>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nvm 入门</title>
      <link href="/Hexo-Blog/2022/11/22/engineering/nvm%20%E5%85%A5%E9%97%A8/"/>
      <url>/Hexo-Blog/2022/11/22/engineering/nvm%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-21"><a href="#11-21" class="headerlink" title="11.21"></a>11.21</h1><p><a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https:<span class="comment">//raw.githubusercontent.com/nvm-sh/nvm/v0.39.2/install.sh | bash</span></span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><p>根据终端不同打开不同的配置文件：~/.bash_profile, ~/.zshrc, ~/.profile, or ~/.bashrc<br>此处使用的是 zsh，使用 <code>code ~/.zshrc</code> 打开 zshrc</p><ul><li>bash: source ~/.bashrc</li><li>zsh: source ~/.zshrc</li><li>ksh: . ~/.profile</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> NVM_DIR=<span class="string">&quot;$([ -z &quot;</span>$&#123;XDG_CONFIG_HOME-&#125;<span class="string">&quot; ] &amp;&amp; printf %s &quot;</span>$&#123;HOME&#125;/.nvm<span class="string">&quot; || printf %s &quot;</span>$&#123;XDG_CONFIG_HOME&#125;/nvm<span class="string">&quot;)&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;$NVM_DIR/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;$NVM_DIR/nvm.sh&quot;</span> # This loads nvm</span><br></pre></td></tr></table></figure><h3 id="3-终端翻墙"><a href="#3-终端翻墙" class="headerlink" title="3. 终端翻墙"></a>3. 终端翻墙</h3><p>代理到你翻墙软件的端口 此处是 33210</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> https_proxy=http:<span class="comment">//127.0.0.1:33210 http_proxy=http://127.0.0.1:33210 all_proxy=socks5://127.0.0.1:33210</span></span><br></pre></td></tr></table></figure><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install node v16<span class="number">.16</span><span class="number">.0</span>    --- 安装 <span class="number">16.16</span><span class="number">.0</span> 版本的 node</span><br><span class="line">nvm ls-remote       --- 查看可使用的 node 版本</span><br><span class="line">nvm use v12<span class="number">.0</span><span class="number">.0</span>     --- 使用 <span class="number">12.0</span><span class="number">.0</span> 版本的 node</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动部署</title>
      <link href="/Hexo-Blog/2022/11/22/engineering/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/"/>
      <url>/Hexo-Blog/2022/11/22/engineering/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2Hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Hello，我是小鱼。</p><p>这个博客是我 2022 年春节时期搭建并部署在阿里云 ECS 服务器上的，后续由于 hexo 静态博客每次更改完文件之后，就得从新 hexo c g d。</p><p>所以时隔多日， 我决定改造一番，本次改造主要是通过 github actions 进行 CI/CD，免去了手动清理，打包，推送到服务器的繁琐流程。</p><p>在后面我会介绍到整个改造的流程以及关于 github actions 的简单介绍和用法讲解~</p><h1 id="什么是-CI-CD-？"><a href="#什么是-CI-CD-？" class="headerlink" title="什么是 CI/CD ？"></a>什么是 CI/CD ？</h1>]]></content>
      
      
      <categories>
          
          <category> 工程化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>预编译</title>
      <link href="/Hexo-Blog/2022/01/27/js/%E9%A2%84%E7%BC%96%E8%AF%91/"/>
      <url>/Hexo-Blog/2022/01/27/js/%E9%A2%84%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（四）-预编译"><a href="#大厂面试题系列（四）-预编译" class="headerlink" title="大厂面试题系列（四）-预编译"></a>大厂面试题系列（四）-预编译</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本期我们要讲的同样是面试干货-预编译的原理，有关于预编译的知识点在小黄书包括很多经典书籍上并没有给出详细的解释和介绍，所以在本文会给大家详细的讲解和介绍。</p><h2 id="发生在函数体的预编译"><a href="#发生在函数体的预编译" class="headerlink" title="发生在函数体的预编译"></a>发生在函数体的预编译</h2><h3 id="关于预编译"><a href="#关于预编译" class="headerlink" title="关于预编译"></a>关于预编译</h3><p>我们再上一期的变量提升中了解到，变量提升是发生在<code>编译阶段</code>，而赋值操作是发生在<code>执行阶段</code>，而预编译，则是<code>发生在执行的前一刻</code>。</p><h3 id="函数执行前一刻的预编译"><a href="#函数执行前一刻的预编译" class="headerlink" title="函数执行前一刻的预编译"></a>函数执行前一刻的预编译</h3><p>这里我们引用一下上一期当中的代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// function () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">//  function () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>还是这段熟悉的代码，唯一的不同之处就在于这次我们在调用函数 fn 的时候，传入了一个参数 1。在上一期当中我们是直接使用变量提升的规则来理清楚了这段函数的运行结果，那么今天我们就用预编译的规则来理一理：</p><p>大家可以先跟我走一遍，存在不明白的地方很正常，先跟着我一起走完一遍，到最后小编会给出总结，到时候大家就能明白了。</p><p>来吧，首先如果有小伙伴对执行上下文还不太了解的话可以去我们系列第二篇（作用域进阶）了解一下执行上下文之后再来学习本期内容，会更好理解一些。</p><p>首先，我们都知道函数执行会产生一个函数的执行上下文，我们在这里简称为 AO(Activation Object)，那么<code>在AO当中储存的正是函数当中各种变量的值</code>，在例 1.1 当中，函数 fn 执行会产生一个 AO 对象。</p><p>在创建 AO 对象之后，我们<code>先来找有无变量声明和形参</code>，很显然在例 1.1 当中，第一个变量声明是 var a，那么在 AO 中就有一个属性名为 a 的一个变量，那么它的值为多少呢？此时正处于预编译阶段，并不是执行阶段，所以不会执行赋值操作所以 <strong>此时 a 的值为 undefined</strong> 。</p><p>然后我们接着找变量声明，第二个变量声明为 var b，注意，此处<strong>是一个函数表达式，并不是函数声明</strong> ， 那么同样，b 的值也为 undefined，好了，找到这里我们发现已经没有变量声明了。</p><p>那我们来找形参，有一个形参为 a，传入的值为 1，我们<code>将形参与实参的值统一</code>，那么此时 a 的值就为 1.</p><p>走完上面那一步之后我们接着往下看，这个时候我们就可以<code>在函数体里找函数声明</code>，从上往下，第一个就是函数 a 的声明，那么好了，此时 AO 对象中已经存在一个变量 a 了，还会继续添加一个新的 a 为函数吗？很显然在 JavaScript 中是不允许声明两个相同的变量的，所以此时，a 的值 1 将会被覆盖，被[Function: a]覆盖掉了，然后我们继续往下走第二个是函数 d 的声明，同样此时 d 的值为[Function: d]。</p><p>好，走到这里我们算是把函数执行前一刻的预编译理清楚了，然后就是函数内部从上往下执行代码，我们先来看看此时 AO 对象里面存放了哪些值？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.2</span></span><br><span class="line"><span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="literal">undefined</span> -&gt; <span class="number">1</span> -&gt; <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span></span><br><span class="line">    <span class="attr">d</span>: <span class="function"><span class="keyword">function</span> <span class="title">d</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在函数预编译的时候并不会产生上面这么一段代码，而是会产生一个结构，想了解的同学，在第二篇作用域进阶当中有一些图片大家可以看看。</p><p>那么好，预编译执行完了，我们开始执行代码，从上往下，第一个就是 console.log(a)，那么此时的 a 的值为[Function: a]，<strong>所以这行代码运行的结果就为[Function: a]。</strong><br>继续往下看，有一个 a = 123 的赋值操作，将 a 的值又重新赋值为了 123，所以<strong>下面两个 console.log(a)的值都为 123.</strong> ，接着往下走，有一个赋值操作将[Function: b]赋值给了变量 b，所以<strong>最后一个 console.log(b)的值就为[Function: b]。</strong> 到这里，整个过程就算结束了，得出的最后答案和我们通过变量提升直接得出的答案是一样的，还没有理清楚的小伙伴可以多看两边上面的解析，后面我们会一起总结。</p><h2 id="发生在全局下的预编译"><a href="#发生在全局下的预编译" class="headerlink" title="发生在全局下的预编译"></a>发生在全局下的预编译</h2><h3 id="预编译不仅仅发生在函数体内"><a href="#预编译不仅仅发生在函数体内" class="headerlink" title="预编译不仅仅发生在函数体内"></a>预编译不仅仅发生在函数体内</h3><p>预编译同样会发生在全局下，那么在全局下的预编译又是怎样进行的呢？如果你已经理解了函数执行前一刻的预编译，那么接下来你就能很清晰的理解全局下的预编译，也是那么几个步骤，我们先一起走一遍，最后再做个总结。</p><h3 id="全局下的预编译"><a href="#全局下的预编译" class="headerlink" title="全局下的预编译"></a>全局下的预编译</h3><p>同样的，我们先来看一段简单的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">global</span> = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">global</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>好，这段代码是不是异常简单，没错，确实简单，但是有个小细节需要大家注意，一会儿大家就知道了，那么你先想想，这段代码的运行结果会是多少呢？相信你的答案应该是 100，没错，这段代码的运行结果的确为 100，<strong>如果面试官问你，为什么是 100 呢？</strong> 那么你可能就会说因为函数内部可以访问到外部的变量所以为 100，<strong>那么面试官又问了：为什么函数内部可以访问到外部的变量呢？</strong> 这个时候你就可以拿出我们第二篇中所讲到的作用域链的知识来解答了，好，那么真的是这么个流程嘛？我们一起来看看。</p><p>首先，我们执行的前一刻，<code>全局会产生一个GO对象</code>，就是全局的执行上下文，和函数一样，我们先找变量声明，有一个 var global 的声明，所以此时 global 的值为 undefined。</p><p><code>找完了变量声明我们再找函数声明</code>，有个函数 fn 的声明，那么此时 GO 中又多了一个变量 fn，值为[Function: fn],到这里全局的预编译就执行完了，然后就是函数 fn 也会进行预编译，按照上一节所讲的步骤可知函数 fn 的 AO 对象里面没有变量（本身自带的一些 this，arguments 除外），所以现在的 AO 和 GO 我们来看一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.2</span></span><br><span class="line"><span class="attr">GO</span>: &#123;</span><br><span class="line">    <span class="attr">global</span>: <span class="literal">undefined</span> ,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">AO</span>:&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行阶段，因为赋<strong>值操作是在函数 fn 的调用之前，所以会先进行赋值操作，再进行函数的调用</strong>，所以最终代码运行结果为：100</p><h2 id="预编译总结"><a href="#预编译总结" class="headerlink" title="预编译总结"></a>预编译总结</h2><p>好了讲到这里想必大家多多少少对预编译的过程有个大概的了解了，那么我再来给大家总结一下：<br>首先，预编译发生在函数执行前的前一刻 ( 四部曲 ) ( 函数体 )</p><ol><li><p>Js 引擎会创建 AO 对象(Activation Object)</p></li><li><p>找形参和变量声明，将变量声明和形参作为 Ao 的属性名，值为 undefined</p></li><li><p>将实参和形参值统一</p></li><li><p>在函数体里找函数声明，将函数名作为 Ao 对象的属性名，值赋予函数体</p></li></ol><p>发生在全局下的预编译：</p><ol><li><p>创建 GO 对象</p></li><li><p>找形参和变量声明，将变量声明和形参作为 GO 的属性名，值为 undefined</p></li><li><p>在全局里找函数声明，将函数名作为 GO 对象的属性名，值赋予函数体</p></li></ol><p>如果看到第三节还是一知半解的同学，我建议可以把小结多看几遍，然后根据总结的部分再回到前面去看看能不能自己写出来 AO 和 GO。</p><p>本期文章就写到这里啦，我们下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升</title>
      <link href="/Hexo-Blog/2022/01/27/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/Hexo-Blog/2022/01/27/js/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（三）-变量提升"><a href="#大厂面试题系列（三）-变量提升" class="headerlink" title="大厂面试题系列（三）-变量提升"></a>大厂面试题系列（三）-变量提升</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会讲到的主要内容也是前端面试绕不开的一大话题<strong>变量提升</strong>，看到这篇文章的朋友们想必已经对作用域和作用域链有了一个基本的了解了，如果还不了解的话建议看看小编的面试系列一和二，对理解本文会有一点帮助，那么话不多说，我们步入主题。</p><h2 id="代码是怎么运行的"><a href="#代码是怎么运行的" class="headerlink" title="代码是怎么运行的"></a>代码是怎么运行的</h2><p>首先我们来看看代码是怎么运行的，大家都知道<strong>JavaScript 中执行顺序是从上到小的</strong>,那么在运行的过程中，是否真的是简单的从上往下执行呢？我们来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.1</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><h3 id="变量提升发生的场景"><a href="#变量提升发生的场景" class="headerlink" title="变量提升发生的场景"></a>变量提升发生的场景</h3><p>这段代码很简单，打印结果为 <strong>小明 hello</strong> ，好，那我们再看接下来的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.2</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>那么这段代码的运行结果又是什么呢？按照代码从上往下执行的原则，结果会报错，为什么呢？因为打印 myName 的时候还没有声明 myName，所以会报错，那么结果真的会是这样吗？</p><p>不，这段代码的运行结果是 <strong>undefined hello</strong> ， 哎，很多同学到这可能就有很多疑问了，问什么会是 undefined 呢？ 好，先不要着急，我们接着看一段代码：</p><h3 id="函数提升发生的场景"><a href="#函数提升发生的场景" class="headerlink" title="函数提升发生的场景"></a>函数提升发生的场景</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.3</span></span><br><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&quot;小明&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多小伙伴看到这里就会说了，哎在例 1.2 中打印的是 undefined，那么这里 shouName()，同样也是在声明之前调用，那么结果一定是两个 undefined 吧，实则不然，这段代码的打印结果是 <strong>hello undefined</strong> ，看到这里想必有些小伙伴已经脑袋晕了吧，不要着急，我们先做个小总结：</p><h3 id="代码运行小结"><a href="#代码运行小结" class="headerlink" title="代码运行小结"></a>代码运行小结</h3><ul><li><p>  在执行过程中，若使用未声明的变量，Js 执行会报错</p></li><li><p>  在一个变量定义之前使用它，不会报错，但是该变量的值为 undefined ，而不是定义的值</p></li><li><p>  在一个函数定义之前使用它，是不会报错的，且函数能正确执行</p></li></ul><h2 id="变量提升现象"><a href="#变量提升现象" class="headerlink" title="变量提升现象"></a>变量提升现象</h2><p>首先，什么是变量提升呢？变量提升就是： <strong>javascript 代码在执行过程中，javascript 引擎会把变量声明部分和函数声明部分提升到代码的最前面的”行为”</strong></p><p>在例 1.2 中，在编译阶段会发生变量提升现象，所以引擎执行时候的代码可以理解成以下样子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myName;</span><br><span class="line"><span class="built_in">console</span>.log(myName);</span><br><span class="line">myName = <span class="string">&quot;小明&quot;</span></span><br><span class="line">showName()</span><br></pre></td></tr></table></figure><p>这样一看，是不是就能合理的解释为什么运行结果是 undefined 和 hello 了。这就是 JavaScript 当中存在的变量提升，从例 2.1 当中我们看到函数整体和变量 myName 的声明提升到了当前作用域的顶端，相信细心的小伙伴此时就会发现，<strong>函数是整体提升，而变量只有声明部分被提升了，赋值部分仍然留在原地</strong>。另外一点，也是一个小细节：<strong>函数声明提升的优先级是高于变量声明提升的。</strong></p><h3 id="变量提升优先级"><a href="#变量提升优先级" class="headerlink" title="变量提升优先级"></a>变量提升优先级</h3><p>来看下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>我把代码运行结果写在下面，因为可以让大家先自己想一想运行结果是个什么样子，然后再来到下面对比一下看看自己有没有写对。那么以上代码按顺序打印的结果是：[Function: a] ， 123 ， 123 ， [Function: b] 。我觉得只要理解了上文讲的变量提升，想必大家都能理解这段代码的运行结果，那么仍然不太理解的小伙伴也不要着急，我们一起来看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> b ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// function () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);    <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(b);     <span class="comment">//function&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>好了，这么一看，大家是不是就能完全理解变量提升了。如果还不能理解的话，我建议可以多看看上面这两段代码，直到能完全理解它。</p><h3 id="用-let-和-const-声明的变量是否存在变量提升？"><a href="#用-let-和-const-声明的变量是否存在变量提升？" class="headerlink" title="用 let 和 const 声明的变量是否存在变量提升？"></a>用 let 和 const 声明的变量是否存在变量提升？</h3><p>初步理解了变量提升之后，那么问题又来了，用 let 和 const 声明的变量是否存在变量提升呢？来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>以上代码运行结果为 2,2。相信大家应该能理解，那么我们再来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>那么这段代码的运行结构还会是 2,2,吗？不，在这段代码中，由于变量 a 都是由 let 声明的，而用 let 声明的变量是支持块级作用域的，所以在 if{}内部声明的 let a = 2 和外面声明的 let a = 1 是在两个不同的作用域中，所以 if 当中声明的变量 a 无法提升到外部，所以这么来看的话 let 声明的变量是不存在变量提升的，为什么呢？这就涉及到另一个知识点了。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>暂时性死区（temporal dead zone，简称 TDZ）是指：ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<strong>其次在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</strong>。</p><p>正是因为这种机制，所以用 let 声明的变量是不会发生变量提升现象的，更准确的来说，也可以这么理解，let 声明的变量是存在变量提升的，但是由于存在暂时性死区，导致变量提升的效果不存在了，所以这么来看的话，我们可以直接理解为用 let 声明的变量不存在变量提升。</p><p>暂时性死区方便了我们日常使用，防止变量泄露到外部，导致运行出错。</p><h2 id="变量提升小结"><a href="#变量提升小结" class="headerlink" title="变量提升小结"></a>变量提升小结</h2><ol><li><p>变量提升是 javascript 代码在执行过程中，javascript 引擎会把变量声明部分和函数声明部分提升到代码的最前面的”行为”</p></li><li><p>变量提升只是变量声明部分提升</p></li><li><p>函数提升是函数整体提升</p></li><li><p>变量提升发生在编译环节，而赋值操作发生在执行阶段</p></li><li><p>函数声明提升会优先于变量声明提升（导致变量声明被覆盖）（若是还有函数名相同的函数需要提升，则会覆盖之前提升的函数声明）</p></li><li><p>用 let 声明的变量不存在变量提升现象</p></li></ol><p>好的，记住以上内容，如果还有不理解的地方的话可以收藏本文，先往下看，以后可以回过头来看看，就会理解的更深刻一些。</p><p>本系列会由浅入深，全面的讲解到前端面试所需要具备的知识体系，所以看完的小伙伴觉得作者写的还不错的话可以点点不要钱的赞，支持一下，同时也方便以后查找，我们下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS作用域进阶</title>
      <link href="/Hexo-Blog/2022/01/25/js/scoped2/"/>
      <url>/Hexo-Blog/2022/01/25/js/scoped2/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列（二）-作用域进阶"><a href="#大厂面试题系列（二）-作用域进阶" class="headerlink" title="大厂面试题系列（二）-作用域进阶"></a>大厂面试题系列（二）-作用域进阶</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要会对系列（一）所讲解的作用域进行更深一层的讲解，包括<strong>作用域的查找规则</strong>，<strong>执行上下文</strong>和<strong>作用域链</strong>三个方面的内容。</p><h2 id="作用域的查找规则"><a href="#作用域的查找规则" class="headerlink" title="作用域的查找规则"></a>作用域的查找规则</h2><p>在上文中，我们提到作用域的相关概念：<strong>作用域是一套设计良好的规则来储存变量，并且之后可以方便的找到这些变量</strong>。那么作用域是如何查找和访问变量的呢？在本节中会给出答案。</p><h3 id="演员表和对话"><a href="#演员表和对话" class="headerlink" title="演员表和对话"></a>演员表和对话</h3><p>在学习作用域的过程中，我们可以将整个过程模拟成几个人物之间的对话。那么首先我们先来认识一下这场对话中的的‘演员们’，先来一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先介绍一下演员表：</p><ul><li><p>  <strong>引擎</strong>：从头到尾负责整个 JavaScript 程序的编译及执行过程</p></li><li><p>  <strong>编译器</strong>：引擎的好朋友之一。负责语法部分分析及代码生成等脏活累活</p></li><li><p>  <strong>作用域</strong>：引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，以确定当前执行代码对这些标识符的访问权限。</p></li></ul><p>例 1.1 是一个简单的声明赋值语句，那么当这句代码执行的时候，演员们是如何工作的呢？</p><p>在执行变量的赋值操作时，会执行两个工作：</p><ol><li><p>首先编译器会在当前作用域中声明一个变量（如果之前没有声明过）</p></li><li><p>在运行时，引擎会在作用域中查找该变量，如果能找到就会对它进行赋值</p></li></ol><p>也就是说在例 1.1 当中，首先 var a 声明一个变量 a，然后引擎在作用域中查找到变量 a，进行 a = 2 的赋值操作。</p><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>在例 1.1 当中，引擎会为变量 a 进行 LHS 查询，另外一个查找类型叫做 RHS。</p><p>顾名思义换句话说：当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时，进行 RHS 查询。</p><ul><li><p>  <strong>LHS：试图找到变量的容器本身，从而对其进行修改（赋值）</strong></p></li><li><p>  <strong>RHS：简单的查找某个变量的值，不用对其进行操作。</strong></p></li></ul><p>那么这么讲，你是否明白了什么时候用 LHS，什么时候用 RHS 呢？</p><h3 id="引擎和作用域的对话"><a href="#引擎和作用域的对话" class="headerlink" title="引擎和作用域的对话"></a>引擎和作用域的对话</h3><p>上面讲到了引擎会为变量进行 LHS 或 RHS，在这个过程中，作用域发挥一个怎么样的作用呢？先来一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>让我们来看一段引擎和作用域之间的对话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">引擎:我说作用域，我需要为foo 进行RHS 引用。你见过它吗?</span><br><span class="line">作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。</span><br><span class="line">引擎:哥们太够意思了!好吧，我来执行一下 foo。</span><br><span class="line">引擎:作用域，还有个事儿。我需要为a进行LHS 引用，这个你见过吗?</span><br><span class="line">作用域:这个也见过，编译器最近把它声明为foo的一个形式参数了，拿去吧。</span><br><span class="line">引擎:大恩不言谢，你总是这么棒。现在我要把<span class="number">2</span>赋值给a。</span><br><span class="line">引擎:哥们，不好意思又来打扰你。我要为<span class="built_in">console</span> 进行RHS 引用，你见过它吗?</span><br><span class="line">作用域:咱俩谁跟谁啊，再说我就是干这个的。这个我也有，<span class="built_in">console</span>是个内置对象。给你。</span><br><span class="line">引擎:么么哒。我得看看这里面是不是有log(..)。太好了，找到了，是一个函数。</span><br><span class="line">引擎:哥们，能帮我再找一下对a的RHS引用吗?虽然我记得它，但想再确认一次。</span><br><span class="line">作用域:放心吧，这个变量没有变动过，拿走，不谢。</span><br><span class="line">引擎:真棒。我来把a的值，也就是<span class="number">2</span>，传递进log(..)。</span><br></pre></td></tr></table></figure><p>就是上面这段经典的对话，生动的描绘出了引擎和作用域是如何配合工作的看到这里相信你已经对作用域的查找规则有个清晰的认识了。</p><p>所以在这里留下一道题给大家练练手：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>请问在例 1.3 中有几处 LHS 查询，几处 RHS 查询呢？欢迎大家在评论区留下答案。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d1d45865ba24c0ca597342e8a9d9bf8~tplv-k3u1fbpfcp-watermark.image" alt="作用域.png"></p><p>还是这张熟悉的图，在图中我们可以看到最内层的 bar 函数作用域，中间有 foo 的函数作用域，最外层存在全局作用域，那么这样一个嵌套的过程，就被称为<strong>作用域嵌套</strong>。</p><p>所以什么叫做作用域链呢：当引擎从当前的作用域开始查找变量，如果找不到，就会向上一级继续查找，直到找到变量或者已经到达全局作用域仍然找不到就会停止，那么在这个查找过程中，会<strong>产生一个成链式连接的集合：储存着执行期上下文对象的集合</strong>，这种结构就可以称为作用域链。那么什么是执行上下文呢？我们接着往下看</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>那么什么又是执行上下文呢？</p><p>在作用域中，储存着<strong>运行期的上下文</strong>：当函数执行时会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是<strong>独一无二</strong>的，所以多次调用一个函数会导致创建多个执行上下文，当函数执行完毕，它所产生的执行上下文会被销毁</p><p>先来一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">3.1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">234</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">    b()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> glob = <span class="number">100</span></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>那么在上面这段代码执行时会产生什么呢？我们先看一张图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3679d21db6554112913669dc54b67258~tplv-k3u1fbpfcp-watermark.image" alt="2.jpg"></p><ul><li><p>  首先是函数 a 声明的时候会产生一个 <strong>[[scope]]</strong>,其中就包含着一个一个的执行上下文，这些集合就被称为<strong>scope chain</strong>（作用域链），因为函数 a 定义在全局，所以一定会有一个 <strong>Global Object</strong>（全局执行上下文），在全局上下文中，包含一些内置的键值对，包括 this，指向 window，以及我们在全局定义的变量 glob，值为 100.</p></li><li><p>  当执行到 a() 时，执行函数 a，会产生 a 的执行上下文：</p></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8e786cd3494a809cbe4b1678f9c514~tplv-k3u1fbpfcp-watermark.image" alt="2.png"></p><ul><li><p>  当 a 执行的时候（橙色线条），GO（全局执行上下文）在作用域链中会被挤到 1 的位置上，函数 a 自己的执行上下文（AO）会挤到最顶端，也就是 0 的位置，这也就是为什么查找变量是由内而外，<strong>从作用域链的最顶端开始查找</strong>。</p></li><li><p>  最后在函数 a 当中执行函数 b 的时候，也是相同的规则：</p></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3696de0922b44e1d8b5db84b9c9a8c57~tplv-k3u1fbpfcp-watermark.image" alt="3.png"></p><ul><li>  红色的线条代表的就是函数 b 被执行的时候，0 的位置存放着 b 的执行上下文，1 的位置放着 a 函数 a 的执行上下文，2 的位置上放着全局的执行上下文。</li></ul><p>如果有文章中写的不够透彻或者有不明白的地方欢迎在评论区留言~<br>本期就讲到这里了，下期见~</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS作用域(一)</title>
      <link href="/Hexo-Blog/2022/01/24/js/scoped/"/>
      <url>/Hexo-Blog/2022/01/24/js/scoped/</url>
      
        <content type="html"><![CDATA[<h1 id="大厂面试题系列-初识作用域"><a href="#大厂面试题系列-初识作用域" class="headerlink" title="大厂面试题系列-初识作用域"></a>大厂面试题系列-初识作用域</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>前端面试必考题-作用域，算是入门级必须掌握的一块知识，JavaScript 中有一个特性叫作用域（Scope）</p><p><strong>scope: 每个 javascript 函数都是一个对象，对象中有些属性是我们可以访问的，但是有些不可以，scope 这个属性就是其中之一，它只能被 javascript 引擎存取</strong></p><p>话不多说，先上一段简短的代码体验一下作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>看完上面这段代码，请问打印出的 2 个 a 的值是多少呢？都是 1 吗？相信有基础的同学一眼就能看出答案：第一个 a 的值为 1，第二个 a 应该会报错（ a is not defined）。这个时候不知道有没有同学会觉得，a 不是等于 1 吗？为什么会报错呢？这就是作用域了，下面我们就一起来揭秘一下~</p><h2 id="初识作用域"><a href="#初识作用域" class="headerlink" title="初识作用域"></a>初识作用域</h2><p>注：有基础的同学可以直接跳过这一节</p><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>小黄书上对作用域的解释是：<strong>作用域是一套设计良好的规则来储存变量，并且之后可以方便的找到这些变量</strong>。刚接触 js 的小白们看不懂也不要紧张，接着往后看，看完还不懂评论区留言我上门一对一辅导哈哈哈~<br>话不多说，接着上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a,b,c );</span><br><span class="line">    &#125;</span><br><span class="line">    bar( b * <span class="number">3</span> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，存在着三个作用域：</p><ol><li>整个全局的作用域，在此作用域中只存在 foo 一个标识符。</li><li>函数 foo 所创建的作用域，在此作用域中存在 a，bar，b 三个标识符。</li><li>函数 bar 所创建的作用域，在此作用域中只存在 c 一个标识符。<br>下面上个经典的图来理解例 1.2 当中的作用域：</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a83965146064ba48d6249522b7be219~tplv-k3u1fbpfcp-watermark.image" alt="作用域.png"></p><p>不同颜色的气泡代表着不同的作用域，这样看作用域是不是更加显而易见。包括作用域中所存在的各个标识符。<strong>作用域气泡由其对应的作用域代码块写在哪里决定，它们是逐级包含的。后面会讲到不同类型的作用域，现在只要假设每一个函数都会创建一个作用域气泡就好了</strong>。</p><p>在此处先介绍一下作用域的两种主要的工作模式：第一种是最为普遍的，被大多数编程语言所采用的<strong>词法作用域</strong>，后面会对词法作用域进行深入的讲解。另外一种叫作<strong>动态作用域</strong>，后面也会略做讲解。</p><h3 id="作用域的作用是什么？"><a href="#作用域的作用是什么？" class="headerlink" title="作用域的作用是什么？"></a>作用域的作用是什么？</h3><p><strong>作用域是在运行的时候，对某些变量，函数和对象的可访问性</strong>。什么意思呢？我们还是来看一段代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">1.3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// a is not defined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么这里打印 a 的值会是 not defined 呢？ 正是因为变量 a 是在函数 foo 中定义的，所以在全局环境下打印变量 a 自然会报错。</p><p>所以对于作用域的作用是什么我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><h2 id="作用域全家桶"><a href="#作用域全家桶" class="headerlink" title="作用域全家桶"></a>作用域全家桶</h2><p>在例 1.2 和 1.3 中我们都提到了全局作用域和函数作用域，那么在这一节中我们将会对‘作用域全家桶’有个深入的了解。</p><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>什么是全局作用域？简单通俗的来说就是：<strong>定义在全局下的变量或函数都处在全局作用域当中。</strong></p><p>那么什么时候会产生全局作用域呢？话不多说，接着上代码：</p><p>（1）定义在全局的变量和函数，就会产生全局作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;我是全局变量&#x27;</span>      <span class="comment">//  定义在全局的变量a</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;     <span class="comment">//  定义在全局的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&#x27;我在函数里面&#x27;</span>   <span class="comment">//    定义在函数foo中的变量b</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;    <span class="comment">//  定义在函数foo中的函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 a 和函数 foo 就处在全局作用域下，而变量 b 和函数 bar 在函数 foo 所产生的的函数作用域当中。</p><p>（2）直接赋值的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo()   <span class="comment">// 执行foo才能执行里面的代码</span></span><br><span class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// b is not defined</span></span><br></pre></td></tr></table></figure><p>为什么这里的变量 a 会有值呢？因为变量 a 未声明而是直接赋值，所以会自动放入全局作用域中，而变量 b 就是正常情况下，定义在函数 foo 作用域中的变量在全局下无法访问。</p><p><strong>全局作用域的弊端</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>如上所示，一旦代码量过于复杂，可能就会存在变量名相同的情况，导致命名冲突。</p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>什么是函数作用域呢？简单来说：<strong>函数作用域就是在声明函数的时候，会产生一个作用域，这个作用域就被称为函数作用域</strong>。先上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    bar()</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">        <span class="built_in">console</span>.log(b);     <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">console</span>.log(a);     <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a);         <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);             <span class="comment">// a is not defined</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>在这段代码中，第一个打印 b 为 1，是因为变量 b 是在函数 bar 的作用域中定义，所以可以正常打印出 b 的值。第二个打印 a 为什么值为 2，这是因为在函数作用域中，<strong>内部的作用域可以访问到外部作用域的变量</strong>，而通过第四个打印 a 的值为 not defined 可以看出来，<strong>从外部是无法访问到函数内部变量的</strong>。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES6 中引入的块级作用域，增加了对变量的可控性，大大的提高了变量使用的灵活性。</p><p>那么块级作用域在什么时候产生呢？-块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。<strong>一个块级作用域可以理解为一对花括号{}之间的区域</strong>。接着上代码：</p><p>（1）函数中的块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);     <span class="comment">//  1</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">console</span>.log(a);         <span class="comment">//  a is not defined</span></span><br></pre></td></tr></table></figure><p>用 let 声明的变量 a 只在函数 foo 中有定义，而在此块级作用域外则没有定义。</p><p>（2）for 循环中的块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.6</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// 0,1,2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);         <span class="comment">// i is not defined</span></span><br></pre></td></tr></table></figure><p>变量 i 只在 for 循环中有定义，因为用 let 声明变量 i 产生了块级作用域，而在 for 循环外面则无法访问到变量 i。</p><p>相信很多小伙伴看到例 2.6 的时候会有这么个疑惑：let 声明的变量 i 到底是在括号内的作用域中还是在 for 循环内部的{}中呢？让我们来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(i);     <span class="comment">// a,a,a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，循环体打印出了三个 a，<strong>这说明在 for 循环当中，在括号内用 let 声明的变量会产生一个父作用域，而在循环体内会产生一个子作用域，那么为什么例 2.6 可以打印出 1,2,3 呢？这是因为内部作用域可以访问到外部作用域，在这里就是说，子作用域可以访问到父作用域的变量 i</strong>，看到这里相信你一定对块级作用域有个认知了吧。</p><p><strong>注意：不可重复声明变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">2.8</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>    <span class="comment">//  Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在一个作用域中重复声明变量则会报错。</p><h2 id="作用域收关"><a href="#作用域收关" class="headerlink" title="作用域收关"></a>作用域收关</h2><p>看完了上面两节的内容相信大家已经对作用域有个初步的认识了吧，在第三节中，会聊到一些拓展以及作用域之后相关的内容，在后续也会更新发布本系列。</p><h3 id="作用域相关知识概要"><a href="#作用域相关知识概要" class="headerlink" title="作用域相关知识概要"></a>作用域相关知识概要</h3><p>在本文中只谈到了作用域的概念和一些不同的作用域，其实在作用域中还存放着一个叫做<strong>执行上下文</strong>的东西，以及<strong>作用域的查找规则</strong>和<strong>变量提升</strong>等内容，要学习这些内容必须熟练掌握作用域的知识所以在后续会发布相关文章来详细讲解面试系列。</p><h3 id="作用域产生的作用域链"><a href="#作用域产生的作用域链" class="headerlink" title="作用域产生的作用域链"></a>作用域产生的作用域链</h3><p>在此先简单的提到一下由许多作用域产生的作用域链，本系列中将作用域和其他相关内容分开，可以将每个内容的部分更加详细的描述到。</p><p><strong>作用域链：scope 中存储的执行期上下文对象的集合，这个集合成链式连接，我们把这种链式连接叫做作用域链</strong></p><p>觉得作者写的还行的可以动动小手点个赞支持一下哦，也可以关注作者，后续会写一整套面试系列内容~ 本文中存在错误也可以在评论区讨论哦！</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
